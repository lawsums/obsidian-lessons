
**《算法设计与分析》期末考试复习纲要**

# 第一章
**掌握算法的基本概念**；掌握算法的五个重要特征；理解算法学习的重要性；理解算法的设计、分析和求解的基本过程；能够知道哪一类应用问题应该用哪一类算法来解决；算法的分类。

- [x] ![[掌握算法的基本概念]]
- [x] ![[掌握算法的五个重要特征]]
- [x] ![[算法的分类]]

# 第二章 
理解什么是一个好的算法；理解算法的最好、最坏和平均时间复杂度；掌握渐近分析的记号：O、Ω、θ 、o、ω的基本概念并且会灵活应用；能够求解出其时间复杂度；**掌握常见的大O记号时间复杂性计算和比较；掌握递推式的求解方法。**
 
- [x] [算法基础、分治法、快速排序、二分搜索等常考题型讲解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Va4y177JK/?spm_id_from=333.788.recommend_more_video.1&trackid=web_related_0.router-related-2206419-t84qs.1768276040854.464&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] **掌握常见的大 O 记号时间复杂性计算和比较；**
- [x] **掌握递推式的求解方法。**

# 第五章
掌握分治法的基本概念/特征/要素；了解汉诺塔等递归问题；理解求最大最小元、**二分搜索**和两路合并排序的基本思想；**掌握快速排序的基本思想以及改进策略；** 选择算法随机选取主元和改进主元选取两种方法的区别；**斯特拉森矩阵分治法**。

- [x] **掌握快速排序的基本思想**
- [x] **以及改进策略；** 
- [x] 选择算法随机选取主元和改进主元选取两种方法的区别
- [x] **斯特拉森矩阵分治法**
## 快速排序
### 一、快速排序的基本思想
快速排序（Quick Sort）是 **分治算法** 的经典应用，核心思想是「**选主元→分区→递归排序**」，通过将原问题拆解为更小的子问题，逐步缩小排序范围，最终实现整体有序。具体步骤如下：

#### 1. 核心三步（分治逻辑）
- **步骤1：选择主元（Pivot）**  
  从待排序数组中挑选一个元素作为「主元」（通常选第一个、最后一个、中间元素，或随机元素），主元是分区的基准。
- **步骤2：分区（Partition）**  
  重新排列数组，将 **所有小于主元的元素放到主元左侧**，**所有大于主元的元素放到主元右侧**，等于主元的元素可放左侧或右侧（不影响最终结果）。分区后，主元的位置被永久确定（即排序后的最终位置）。
- **步骤3：递归排序**  
  对主元左侧的子数组和右侧的子数组，重复「选主元→分区」步骤，直到子数组的长度为 0 或 1（天然有序，递归终止）。

#### 2. 简单示例（以数组 [5, 2, 9, 3, 7, 6, 1] 为例）
- 选主元：假设选第一个元素 5；
- 分区：遍历数组，将小于 5 的元素 [2, 3, 1] 放左侧，大于 5 的元素 [9, 7, 6] 放右侧，得到 [2, 3, 1, 5, 9, 7, 6]，主元 5 位置固定；
- 递归：分别对左侧 [2, 3, 1] 和右侧 [9, 7, 6] 重复上述步骤，最终得到有序数组 [1, 2, 3, 5, 6, 7, 9]。

#### 3. 时间复杂度与空间复杂度
- **最佳/平均时间复杂度**：$O(n\log n)$（每次分区能将数组均匀分成两部分，递归深度为 $\log n$，每层分区耗时 $O(n)$）；
- **最坏时间复杂度**：$O(n^2)$（当数组已有序/逆序，且主元选首尾元素时，分区后子数组一边为空、一边为 $n-1$ 个元素，递归深度为 $n$）；
- **空间复杂度**：$O(\log n)$（递归调用栈的空间，平均情况）/ $O(n)$（最坏情况，递归深度为 $n$）；
- **稳定性**：不稳定（分区过程中，相同元素的相对位置可能被改变，如 [3, 2, 3, 1] 选主元 3 时，右侧的 3 会被放到左侧 2 前面）。


### 二、快速排序的改进策略（解决最坏情况+提升效率）
原始快速排序的核心问题是「主元选择不当导致的最坏时间复杂度」和「小规模子数组递归效率低」，常见改进策略如下：

#### 1. 改进主元选择（核心改进，重点解决 $O(n^2)$ 问题）
- **问题根源**：原始方法选首尾/固定位置主元，在有序数组中会导致分区极度不均；
- **改进方向**：让主元尽可能“居中”，使分区后的子数组规模接近；
- **具体方法**：
  - 随机选取主元（下文详细对比）；
  - 三数取中法（Median of Three）：从数组的「左端、右端、中间」选三个元素，取其中位数作为主元（如 [5,2,9,3,7,6,1] 选 5（左）、1（右）、3（中），中位数 3 作为主元）；
  - 九数取中法（进一步优化）：将数组分成三组，每组取三数中位数，再从三个中位数中取中位数作为主元，适用于大规模数组。

#### 2. 小规模子数组改用插入排序
- **问题根源**：递归到小规模子数组（如长度 ≤ 10）时，快速排序的递归开销（函数调用、栈操作）占比过高，而插入排序在小规模有序/接近有序数据上效率更高；
- **改进逻辑**：当子数组长度小于阈值（如 5~20，可根据实际场景调整）时，停止递归，直接用插入排序处理该子数组。

#### 3. 三路快排（解决重复元素过多的问题）
- **问题根源**：当数组包含大量重复元素时（如 [2,1,3,2,2,5,2]），原始快排会将重复元素全部归到主元一侧，导致分区不均；
- **改进逻辑**：分区时将数组分成三部分——「小于主元」「等于主元」「大于主元」，递归时仅处理「小于」和「大于」的两部分，「等于」的部分已有序，无需递归；
- **优势**：重复元素越多，效率提升越明显，时间复杂度可接近 $O(n)$。

#### 4. 尾递归优化（降低空间复杂度）
- **问题根源**：原始快排的递归调用栈可能因深度过大导致栈溢出（最坏情况 $O(n)$ 深度）；
- **改进逻辑**：递归处理较小的子数组，对较大的子数组采用「尾递归」（或迭代）方式，减少递归调用栈的深度，使空间复杂度稳定在 $O(\log n)$。


### 三、「随机选取主元」与「改进主元选取」（如三数取中法）的区别
这里的「改进主元选取」特指「非随机的优化主元选择方法」（以三数取中法为代表），两者的核心区别围绕「主元的选择逻辑、适用场景、优缺点」展开，具体对比如下：

| 对比维度                | 随机选取主元                                  | 改进主元选取（以三数取中法为例）              |
|-------------------------|-----------------------------------------------|-----------------------------------------------|
| **核心逻辑**            | 从待排序子数组中「随机挑选一个元素」作为主元  | 从子数组的固定位置（左、中、右）选三个元素，取中位数作为主元 |
| **主元的“均衡性”保障**  | 概率性保障：几乎不可能连续选到极端主元（如最小/最大值），长期来看分区接近均匀，最坏时间复杂度 $O(n^2)$ 的概率极低（可视为实际不会发生） | 确定性保障：通过“取中位数”强制主元接近数组中间值，避免选到极端主元，分区均匀性更稳定 |
| **时间开销**            | 低：仅需一次随机数生成+数组元素交换，耗时可忽略 | 略高：需额外比较三个元素的大小（找中位数），但操作数少，总体开销仍可控 |
| **适用场景**            | 通用场景（尤其是数组元素分布未知、无序的情况）；对“避免最坏情况”有基础要求，无需极致稳定性 | 大规模数组、元素分布可能极端（如有序/逆序）的场景；对分区均匀性要求更高，追求稳定的 $O(n\log n)$ 性能 |
| **抗恶意数据能力**      | 较强：恶意构造的有序/逆序数组，随机主元仍能保证分区均匀 | 极强：即使是恶意构造的数据，三数取中法仍能选到中间主元，完全避免最坏情况 |
| **实现复杂度**          | 简单：只需在分区前添加“随机选择主元并与首元素交换”的步骤 | 稍复杂：需计算中间位置、比较三个元素、交换主元，代码量略多 |

#### 补充说明：
1. 两者并非互斥：实际工程实现中（如 C++ STL 的 `sort` 函数），会结合「随机选取」和「三数取中法」——先随机选择几个候选元素，再从候选元素中取中位数作为主元，兼顾“概率均衡”和“确定性稳定”；
2. 避免误区：“随机主元”不是“随便选主元”，其核心是通过随机性规避极端情况，而“三数取中法”是通过确定性逻辑主动选择优质主元，前者侧重“避坑”，后者侧重“选优”。


### 总结
1. 快速排序的核心是「分治+分区」，主元选择是决定其性能的关键；
2. 改进策略的核心目标是「避免最坏时间复杂度」和「降低额外开销」，主要包括：优化主元选择、小规模子数组用插入排序、三路快排、尾递归优化；
3. 随机选取主元与三数取中法的核心区别：前者靠概率保障分区均匀，实现简单、通用；后者靠确定性逻辑选择优质主元，稳定性更强，适用于大规模或极端分布数据。

## 斯特拉森矩阵

---
#  第六章
掌握贪心法的概念和重要特征及性质；**掌握一般背包问题的求解**；了解带时限的作业排序；**掌握最佳合并模式**；**磁带最优存储**。

- [x] **掌握一般背包问题的求解**；
- [x] [一般背包问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1gQckeAENT?spm_id_from=333.788.videopod.sections&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] 了解带时限的作业排序；
- [x] [分枝限界法 分类：FIFO LIFO LC 15谜问题 带时限的作业排序_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W54y1v7de/?spm_id_from=333.337.search-card.all.click&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] **掌握最佳合并模式**；
- [x] [最佳合并模式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tucQeQECb?spm_id_from=333.788.videopod.sections&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] **磁带最优存储**。
## 磁带最优存储（掌握）
### 1. 问题描述
有n个文件，每个文件的访问频率为 \( f_1, f_2, ..., f_n \)，需存储在一条磁带上。磁带的访问方式为**顺序访问**（访问第i个文件前，需先扫描前i-1个文件），访问代价为“文件长度×访问频率×扫描过的文件数”（简化模型：假设所有文件长度相同，访问代价直接为“访问频率×扫描位置”）。求文件的存储顺序，使得**总访问代价最小**。

### 2. 核心思路（贪心策略）
简化模型（文件长度相同）：**访问频率越高的文件，存储位置越靠前**（减少高频率文件被扫描的次数）。  
推导：设文件顺序为 \( x_1, x_2, ..., x_n \)，总访问代价 \( total = f_{x_1}×1 + f_{x_2}×2 + ... + f_{x_n}×n \)。要最小化total，需让大的 \( f \) 乘以小的系数，因此按频率升序排列（或降序？注意：系数1最小，分配给最大f；系数n最大，分配给最小f → 按频率降序排列）。

### 3. 具体步骤
1. 按文件访问频率 \( f_i \) 从**大到小**排序；
2. 按排序后的顺序存储文件，此时总访问代价最小。

### 4. 示例
- 文件：A(f=10)、B(f=5)、C(f=15)、D(f=8)；
- 排序后（频率降序）：C(15) → A(10) → D(8) → B(5)；
- 总访问代价：15×1 + 10×2 + 8×3 + 5×4 = 15 + 20 + 24 + 20 = 79（最优解）；
- 若逆序存储（B→D→A→C）：5×1 +8×2 +10×3 +15×4=5+16+30+60=111（代价更大）。

### 5. 扩展（文件长度不同）
若文件长度不同（设为 \( l_i \)），访问代价为 \( f_i × l_i × 扫描次数 \)，此时贪心策略调整为：按 \( \frac{f_i}{l_i} \)（单位长度访问频率）降序排列，核心逻辑仍是“单位长度访问频率越高，越靠前”。

### 6. 代码实现（Python，简化模型）
```python
def optimal_tape_storage(frequencies):
    # 按频率降序排序
    frequencies.sort(reverse=True)
    total_cost = 0
    for i in range(len(frequencies)):
        # 第i+1个位置（系数i+1）
        total_cost += frequencies[i] * (i+1)
    return total_cost

# 测试
frequencies = [10,5,15,8]
print(f"最小总访问代价：{optimal_tape_storage(frequencies)}")  # 输出79
```


## 总结
| 知识点                | 核心贪心策略                          | 关键前提（性质）                  |
|-----------------------|---------------------------------------|-----------------------------------|
| 贪心法基础            | 局部最优→全局最优                     | 贪心选择性质+最优子结构性质       |
| 一般背包（分数）      | 单位重量价值（性价比）降序            | 允许拆分物品，满足贪心选择性质    |
| 带时限作业排序        | 收益降序+最晚空闲时间分配             | 最优子结构，高收益优先            |
| 最佳合并模式          | 每次合并最小的两个序列（最小堆）      | 短序列早合并减少总代价            |
| 磁带最优存储          | 访问频率（或单位长度频率）降序        | 高频率文件减少扫描次数            |


贪心法的核心是“选对贪心策略”，需先验证问题是否满足贪心选择性质和最优子结构性质，再通过排序、堆等数据结构高效实现决策过程。


# 第七章
**掌握动态规划方法的基本概念及特征，** 以及如何用动态规划法解决实际问题；理解什么是“备忘录方法”；掌握关键路径求解方法。**了解矩阵连乘的基本思想；掌握最长公共子序列的求解方法；掌握用阶跃点求解0/1背包问题的方法**；掌握最优二叉搜索树的求解方法。比较动态规划法、贪心法和分治法的异同。

- [x] 理解什么是“备忘录方法”； -> 记忆化搜索
备忘录方法（Memoization，也常译为 “记忆化搜索”）是**动态规划算法的一种变形实现方式**

- [x] **掌握动态规划方法的基本概念及特征，** 
- [x] [动态规划法 AOE网络（最长路径） 弗洛伊德算法 最长公共子序列 01背包问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1L54y1U7zP/?spm_id_from=333.788.recommend_more_video.-1&trackid=web_related_0.router-related-2206419-gx8f2.1768275969673.33&vd_source=cf6228c0b4a5c283905e22fd11934994)
## 动态规划方法的核心特征
### 1. 重叠子问题
- **定义**：在求解原问题的过程中，多个不同的状态会重复依赖同一个子问题的解，即子问题被多次计算。
- **示例**：计算斐波那契数列时，`fib(5) = fib(4) + fib(3)`，`fib(4) = fib(3) + fib(2)`，其中`fib(3)`被计算了两次，属于重叠子问题。
- **动态规划的应对**：通过 “备忘录”（自顶向下）或 “DP 表”（自底向上）存储已求解的子问题结果，后续再遇到时直接调用，避免重复计算，将时间复杂度从暴力递归的`O(2ⁿ)`降至`O(n)`或`O(nm)`。
### 2. 最优子结构
- **定义**：原问题的最优解可以由其子问题的最优解有效构造，即 “子问题的最优解是原问题最优解的组成部分”。
- **示例**：最短路径问题中，若从 A 到 C 的最短路径经过 B，那么 A 到 B 的路径必然是 A 到 B 的最短路径，B 到 C 的路径也必然是 B 到 C 的最短路径 —— 这体现了最优子结构。
- **动态规划的应对**：基于最优子结构，通过状态转移方程，从子问题的最优解逐步 “递推” 出原问题的最优解，确保最终结果的最优性。

- [x] **了解矩阵连乘的基本思想；掌握最长公共子序列的求解方法；**
- [x] **掌握用阶跃点求解 0/1 背包问题的方法**；
- [x] [阶跃点求解0-1背包问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ZNcUeoEuk?spm_id_from=333.788.videopod.sections&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] 掌握最优二叉搜索树的求解方法。
- [x] [最优二叉搜索树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oTcUexE8T?spm_id_from=333.788.videopod.sections&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] 比较动态规划法、贪心法和分治法的异同。

# 第八章
掌握回溯法的基本概念和特征；**掌握剪枝函数的设计和状态空间搜索树的生成**；掌握**n-皇后问题求解及其程序实现**；了解蒙特卡罗分析方法 **;掌握子集和数问题的求解及状态空间树的生成**； 0-1背包问题求解及状态空间树生成。

- [x] 掌握回溯法的基本概念和特征；
- [x] [回溯法 状态空间树、剪枝函数 蒙特卡罗解的估计 n-皇后程序 子集和数的状态空间树_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16p4y1v7v6?spm_id_from=333.788.recommend_more_video.-1&trackid=web_related_0.router-related-2206419-tqkgg.1768276075283.14&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] **掌握剪枝函数的设计和状态空间搜索树的生成**；
- [x] 掌握 [[n-皇后问题]]求解及其程序实现；
- [x] **掌握子集和数问题的求解及状态空间树的生成**； 
- [x] 0-1 背包问题求解及状态空间树生成。
## 背包问题的剪枝
每一个物品代表一个选择, 走左边代表选择, 走右边代表不选
1. 左剪枝
   左边如果每个都选那么肯定会有超出背包容量的部分, 那么超出背包容量的节点直接剪枝
2. 右剪枝
   我们是深度有限遍历, 所以中途提前走到最左下的位置, 得到一个 best price, 如果在之后往右边遍历的时候 current price + rest price < best price 就直接剪枝跳过

# 第九章
掌握**分枝限界法的基本概念和特征**以及和回溯法的区别；理解相关函数和代价函数等概念；**掌握15迷问题的求解**；掌握上下界函数的设计方法；**掌**握带时限的作业排序求解方法。比较回溯法和分支限界法的异同。

- [x] 掌握**分枝限界法的基本概念和特征**以及和回溯法的区别；
- [x] 理解相关函数和代价函数等概念；
- [x] **掌握 15 迷问题的求解**；
- [x] [15迷问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1joc8egEu4?spm_id_from=333.788.videopod.sections&vd_source=cf6228c0b4a5c283905e22fd11934994)
- [x] 掌握上下界函数的设计方法；**掌**握带时限的作业排序求解方法。
- [x] 比较回溯法和分支限界法的异同。

## 15 迷问题
15 迷问题（15-puzzle problem）**可以同时使用回溯法和分支限界法求解**，两种方法的核心思路都是通过搜索状态空间寻找可行解，但在搜索策略和效率上有明显差异。

### 一、15 迷问题基础
15 迷问题是一个经典的**状态空间搜索问题**：在 4×4 的网格中，放置 1~15 共 15 个数字方块和 1 个空白格（记为 0），每次可以将空白格**上下左右**的相邻方块移动到空白格位置，目标是将初始状态转换为目标状态（通常为数字按顺序排列，空白格在右下角）。

### 二、回溯法求解 15 迷问题
#### 1. 核心思路
回溯法是一种**深度优先搜索（DFS）** 策略：从初始状态出发，依次尝试空白格的所有合法移动方向（生成新状态），递归探索新状态；若当前状态无法到达目标状态，则**回溯**到上一个状态，尝试其他方向，直到找到解或遍历完所有可能状态。

#### 2. 关键步骤
- **状态表示**：用二维数组 `board[4][4]` 表示当前网格状态，记录空白格的坐标 `(x, y)` 以简化移动逻辑。
- **合法移动判断**：定义移动方向数组 `dirs = [(-1,0), (1,0), (0,-1), (0,1)]`（上下左右），确保移动后空白格坐标不越界。
- **递归回溯**：
  1.  若当前状态等于目标状态，返回 `true`（找到解）。
  2.  遍历所有合法移动方向，生成新状态。
  3.  递归探索新状态，若递归返回 `true`，则记录移动路径并返回 `true`。
  4.  若所有方向都无法找到解，恢复当前状态（回溯），返回 `false`。
- **剪枝优化**：记录上一步的移动方向，避免**重复往返**（例如：刚向上移动，下一步不向下移动），减少无效搜索。

#### 3. 优缺点
- **优点**：逻辑简单，容易实现；对于小规模状态空间（如 2×2、3×3 迷问题）效率较高。
- **缺点**：15 迷问题的状态空间极大（总状态数为 $16! \approx 2 \times 10^{13}$），纯回溯法会陷入**指数级时间复杂度**，几乎无法在有限时间内求解随机初始状态。

### 三、分支限界法求解 15 迷问题
#### 1. 核心思路
分支限界法是一种**广度优先搜索（BFS）或优先队列搜索**策略：它通过**启发式函数**评估每个状态的“优劣”，优先探索更接近目标状态的节点，同时用**剪枝策略**避免重复访问状态，从而大幅提升搜索效率。
在 15 迷问题中，分支限界法通常采用 **A* 算法**（一种最优优先搜索），这是分支限界法的典型应用。

#### 2. 关键步骤
- **状态表示**：除了网格状态和空白格坐标，还需记录**当前步数 `g(n)`** 和**启发值 `h(n)`**，总代价为 `f(n) = g(n) + h(n)`。
- **启发函数设计（核心优化）**
  启发函数 `h(n)` 用于估计当前状态到目标状态的最小步数，必须满足**可采纳性**（即 `h(n)` 不大于实际最小步数），常见选择：
  - **曼哈顿距离**：每个数字方块当前位置与目标位置的曼哈顿距离之和，公式：
    $$h_1(n) = \sum_{i=1}^{15} |x_i - tx_i| + |y_i - ty_i|$$
    其中 $(x_i,y_i)$ 是数字 $i$ 的当前坐标，$(tx_i,ty_i)$ 是其目标坐标。
  - **错位数**：当前状态与目标状态不匹配的数字方块数量（不包括空白格），公式：
    $$h_2(n) = \sum_{i=1}^{15} [board[x_i][y_i] \neq target[x_i][y_i]]$$
    （曼哈顿距离的可采纳性更强，是 15 迷问题的首选启发函数）。
- **优先队列（最小堆）**：按总代价 `f(n)` 从小到大排序，每次取出 `f(n)` 最小的状态进行扩展，确保优先探索最有希望的路径。
- **哈希去重**：用哈希表（如 `unordered_set`）记录已访问的状态，避免重复处理同一状态。
- **终止条件**：当取出的状态等于目标状态时，返回当前步数，即为最优解。

#### 3. 优缺点
- **优点**：通过启发函数和优先队列大幅剪枝，能高效求解 15 迷问题的随机初始状态；A* 算法保证找到的解是**最短路径**（最优解）。
- **缺点**：需要额外的空间存储优先队列和哈希表；启发函数的设计直接影响效率，非可采纳的启发函数可能无法得到最优解。

### 四、两种方法的对比
| 特性                | 回溯法（DFS）| 分支限界法（A* 算法）|
|---------------------|-------------------------|-----------------------------|
| 搜索策略            | 深度优先，盲目搜索      | 最优优先，启发式搜索        |
| 时间效率            | 极低，指数级复杂度      | 较高，依赖启发函数          |
| 空间效率            | 较低，递归栈空间        | 较高，需存储队列和哈希表    |
| 是否保证最优解      | 不保证（找到的可能是长路径） | 保证（A* 算法满足可采纳性） |
| 适用场景            | 小规模迷问题（如 3×3）| 大规模迷问题（如 4×4 15 迷）|

### 五、实现注意事项
1. **状态哈希**：无论是回溯法的剪枝还是分支限界法的去重，都需要将二维数组状态转换为可哈希的类型（如字符串、元组）。
2. **可解性判断**：15 迷问题并非所有初始状态都有解。判断条件：
   - 计算初始状态的**逆序数**（不包括空白格）。
   - 若网格宽度为偶数，逆序数 + 空白格所在行的行数（从下往上数）为偶数时，有解；否则无解。
   - 若网格宽度为奇数，逆序数为偶数时，有解。

---

我可以帮你编写**15 迷问题的 A* 算法实现代码**（C++ 版本，包含启发函数和状态去重），需要吗？

# 第十章
理解什么是难处理问题和易处理问题；理解不确定算法和抽象机模型；**掌握P类和NP类问题的概念及其性质**；掌握NP-难度和NP-完全问题的基本概念和性质。

- [x] 理解什么是难处理问题和易处理问题；
- [x] 理解不确定算法和抽象机模型；
- [x] **掌握 P 类和 NP 类问题的概念及其性质**；
- [x] 掌握 NP-难度和 NP-完全问题的基本概念和性质。
![[Pasted image 20260112143435.png]]


- [x] [简答题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1owiFBmELi?spm_id_from=333.788.videopod.episodes&vd_source=cf6228c0b4a5c283905e22fd11934994&p=2)

**考试题型（闭卷考试）**：选择（20）、填空（20）、简答（50）、算法设计（10）
