`button-home`   `button-anki-open`   `button-anki-update`

DECK: 算法设计与分析简答题
### 一、算法基础概念
1. {Q}算法定义{A}解决特定问题时按照某种步骤一定可以得到问题结果的处理过程{E}
<!--ID: 1768379909711-->

2. {Q}写出算法的5个特性以及所含的含义{A}1.输入：算法有0个或多个输入；2.输出：算法有1个或多个输出；3.有限性：算法步骤有限，能在有限时间内结束；4.有效性：每一步操作都可执行且有确定结果；5.确定性：每一步指令含义明确，无歧义{E}
<!--ID: 1768379909716-->

3. {Q}设计求最大公约数的算法（用自然语言或伪代码表示）{A}**辗转相除法**。核心原理：两正整数的最大公约数等于较大数除以较小数的余数与较小数的最大公约数。自然语言：1.输入正整数a、b，确保a≥b（否则交换）；2.计算r = a % b；3.若r=0，b即为最大公约数；4.若r≠0，令a=b，b=r，重复步骤2 - 4。伪代码：Function gcd(a, b): if a < b: 交换a和b；while b != 0: r = a mod b；a = b；b = r{E}
<!--ID: 1768379909721-->

4. {Q}“好”算法除了满足算法的基本特性以外，还应具备的特性{A}正确性、健壮性、高效性{E}
<!--ID: 1768379909725-->

5. {Q}用计算机求解问题的一般过程{A}1.分析问题；2.建立数学模型；3.选择一个算法；4.进行数学上的算法分析；5.算法实现；6.测试{E}
<!--ID: 1768379909728-->

6. {Q}请叙述算法复杂性、时间复杂性、空间复杂性的含义？写出最好、最坏、平均时间复杂性的定义{A}算法复杂性：消耗计算机资源的量；时间复杂性：消耗时间资源的量；空间复杂性：消耗空间资源的量。最好时间复杂度：所有输入案例中最好情况的时间复杂度，参考意义低；最坏时间复杂度：所有输入案例中最坏情况的时间复杂度，有参考意义；平均时间复杂度：所有输入案例的平均时间消耗，有参考意义{E}
<!--ID: 1768379909733-->

7. {Q}请叙述算法复杂性分析的目的{A}在同一个问题中根据时间/空间复杂度进行性能比较，选择最优算法{E}
<!--ID: 1768379909737-->

8. {Q}针对n个元素的冒泡排序分别就元素比较与元素移动分析时间复杂性{A}比较次数：最好情况 $O(n)$（已有序），最坏情况 $O(n^2)$（逆序）；移动次数：最好情况 $O(1)$（无需交换），最坏情况 $O(n^2)$（每次比较都需交换）{E}
<!--ID: 1768379909740-->

9. {Q}写出复杂性符号及其意义：O(f)，Ω(f)，Θ(f){A}O(f)（上界符号）：h的增长速度不超过f，存在常数C和自然数n₀，n>n₀时h(n)≤C·f(n)；Ω(f)（下界符号）：h的增长速度不低于f，存在常数C和自然数n₀，n>n₀时h(n)≥C·f(n)；Θ(f)（紧界符号）：h和f增长速度同阶，等价于h=O(f)且h=Ω(f){E}
<!--ID: 1768379909744-->

10. {Q}针对非递归程序、递归程序叙述复杂性分析基本方法{A}非递归：分析每段代码/循环的时间复杂度，取最大值；递归：判定递归深度和每层递归的时间复杂度，相乘得到整体复杂度{E}
<!--ID: 1768379909749-->

11. {Q}算法设计与分析经常采用的算法有哪些{A}贪心算法、分治法、动态规划、备忘录方法、回溯法、分支界限法{E}
<!--ID: 1768379909752-->

12. {Q}分别给出递推法、蛮力法的含义{A}递推法：利用问题的递推关系逐步推导结果；蛮力法：枚举所有可能的解决方案，逐一验证是否满足目标条件，找到正确答案或确定无解{E}
<!--ID: 1768379909755-->

13. {Q}利用递推算法解决问题，需要做好哪三个方面的工作{A}1.明确递推关系；2.确定初始条件；3.确定结束条件
14. {Q} 给定正整数 a，m，对非负整数 n，用递推法 / 蛮力法计算 aⁿ被 m 除的余数，分析算法复杂性 {A} 蛮力法：直接计算 aⁿ再取模，时间复杂度O(n)；递推法：1. 逐次取模：每次计算(x∗a)%m，时间复杂度O(n)；2. 快速幂法：分治递推，时间复杂度O(logn){E}
<!--ID: 1768379909759-->

15. {Q} 给定两个字符串 S 和 T，在 S 中查找是否有子串 T，请给出一个蛮力法算法，并说明算法复杂性 {A} 算法：用两个指针，i 遍历 S，j 指向 T 开头；若 S [i]=T [j]，则 i、j 同时后移匹配后续字符；若匹配失败则 i 回溯、j 重置；匹配完全则返回 true，否则遍历结束返回 false。时间复杂度：最好O(len(T))，最坏O(len(S)∗len(T)){E}
<!--ID: 1768379909762-->

16. {Q} 请叙述平面最近点对问题，并说明其蛮力法的算法复杂性 {A} 问题：给定平面上 n 个点，找出距离最近的一对点。蛮力法：计算所有点对的欧氏距离，比较得到最小值。时间复杂度O(n2)（需计算n(n−1)/2个点对的距离）{E}
<!--ID: 1768379909765-->

17. {Q}请建立凸n边形的三角剖分递推式h(n)，并给出计算h(n)的程序{A}递推式（卡特兰数）：$h(n) = \sum_{k=2}^{n-1}h(k)·h(n-k+1)$，边界条件 $h(2)=1$，$h(3)=1$。程序（以C++为例）：
``` cpp
int catalan(int n) {
	if(n<=3) return 1;
	int res=0; 
	for(int k=2;k<n;k++) 
		res+=catalan(k)*catalan(n-k+1); 
	return res;}
```
{E}
<!--ID: 1768379909769-->




### 二、经典算法思想（分治/动态规划/贪心）
19. {Q}分治法的基本思想是{A}将规模大的问题分解为若干结构相似的小规模子问题，递归求解子问题，再合并子问题的解得到原问题解{E}
<!--ID: 1768379909773-->

20. {Q}分治法所能解决的问题一般具有哪几个特征{A}可分解性、最优子结构、子问题独立性、可合并性{E}
<!--ID: 1768379909776-->

21. {Q}写出分治法的基本步骤{A}分解（拆分子问题）、求解（递归/直接解子问题）、合并（子解合成原解）{E}
<!--ID: 1768379909778-->

22. {Q}叙述n个数的归并排序算法的思想，并讨论它的算法复杂性{A}思想：分治法，拆分为两子数组递归排序，再合并有序子数组；复杂度：时间O(nlogn)（最好/最坏/平均），空间O(n){E}
<!--ID: 1768379909781-->

23. {Q}叙述快速排序的基本思想，写出最坏与最好的复杂性{A}思想：选基准划分数组为左右两部分（左≤基准≤右），递归排序子数组；复杂度：最好O(nlogn)，最坏O(n²){E}
<!--ID: 1768379909784-->

24. {Q}叙述动态规划的基本思想是{A}分解为重叠子问题，记录子问题最优解（记忆化），自底向上求解，利用最优子结构得到原问题解{E}
<!--ID: 1768379909786-->

25. {Q}写出动态规划算法的基本步骤{A}定义状态、确定状态转移方程、初始化边界条件、计算最优解、（可选）构造最优解{E}
<!--ID: 1768379909789-->

26. {Q}分治法与动态规划法的相同点与不同点{A}相同：均分解问题，依赖最优子结构；不同：分治法子问题无重叠、自顶向下递归；动态规划子问题重叠、自底向上迭代（或记忆化递归）{E}
<!--ID: 1768379909793-->

27. {Q}何为贪心算法{A}每一步选择当前局部最优方案，期望通过局部最优推导全局最优解，需满足贪心选择性质和最优子结构{E}
<!--ID: 1768379909798-->

28. {Q}叙述动态规划与贪心法的异同{A}相同：均要求最优子结构，用于最优解问题；不同：动态规划全局考虑、自底向上、记录子解、保证最优；贪心局部选择、自顶向下、无需记录子解、不一定最优{E}
<!--ID: 1768379909803-->



### 三、搜索与回溯
29. {Q}叙述深度优先搜索{A}从起始节点出发，沿着一条路径尽可能深入搜索，直到无法继续（无未访问邻接节点），再回溯到上一节点，选择其他未探索路径，重复此过程，本质是“先深后广”的递归/栈驱动搜索{E}
<!--ID: 1768379909807-->

30. {Q}回溯法中常见的两类典型的解空间树是什么？{A}子集树、排列树{E}
<!--ID: 1768379909814-->

31. {Q}叙述回溯法的思想，并给出子集树与排列树的算法框架{A}思想：在解空间树中深度优先搜索，按约束条件剪枝无效路径，逐步构造解，若不满足约束则回溯至上一节点。子集树框架：void backtrack(int t) {if(t>n) 输出解; else {for(int i=0;i<=1;i++) {x[t]=i; if(满足约束) backtrack(t+1);}}} 排列树框架：void backtrack(int t) {if(t>n) 输出解; else {for(int i=t;i<=n;i++) {交换x[t]与x[i]; if(满足约束) backtrack(t+1); 交换x[t]与x[i];}}}（x为解向量，t为当前层，n为问题规模）{E}
<!--ID: 1768379909819-->

32. {Q}叙述广度优先搜索法的算法思想{A}从起始节点出发，先访问起始节点的所有邻接节点（同层节点），再依次访问每个邻接节点的邻接节点（下一层节点），按“先广后深”的顺序逐层搜索，本质是队列驱动的层次遍历{E}
<!--ID: 1768379909825-->


### 四、分支限界与A\*算法
29. {Q}叙述A\*算法的设计思想及估计函数表示中各有关函数的含义{A}设计思想：启发式搜索算法，结合代价函数与启发函数引导搜索，优先扩展最可能找到最优解的节点，保证找到最优解。估计函数f(n)=g(n)+h(n)：g(n)为从起始节点到当前节点n的实际代价；h(n)为从节点n到目标节点的估计代价（需满足h(n)≤实际代价，即可采纳性）；f(n)为从起始节点经n到目标节点的总估计代价{E}
<!--ID: 1768379909830-->

30. {Q}叙述限界分枝法思想{A}又称分支限界法，在解空间树中搜索最优解，通过“分支”生成子节点，“限界”计算目标函数界值，剪枝不优于当前最优解的子树，优先扩展更优节点，高效找到全局最优解{E}
<!--ID: 1768379909835-->

31. {Q}叙述限界分枝法与回溯法的相同点{A}1.均基于解空间树搜索；2.均通过剪枝策略减少搜索范围；3.均用于求解组合优化或约束满足问题；4.均需定义约束条件与目标函数{E}
<!--ID: 1768379909839-->

32. {Q}叙述用限界分枝法设计算法的步骤{A}1.定义问题的解空间及解空间树；2.确定目标函数（最大化/最小化）及限界函数；3.选择搜索策略（队列式/优先队列式）；4.生成节点并计算界值，剪枝无效子树；5.记录当前最优解，直至搜索完所有有效节点，输出最优解{E}
<!--ID: 1768379909843-->

33. {Q}叙述分支限界法的搜索策略{A}1.队列式（FIFO）：按节点生成顺序入队，依次扩展，均匀搜索；2.优先队列式（最大/最小堆）：按节点的目标函数界值排序，优先扩展更优节点（如最小堆用于最小化问题，优先扩展界值最小的节点），提升搜索效率{E}
<!--ID: 1768379909847-->

