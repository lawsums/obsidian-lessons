/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WhichKey
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/editor/editor-listener.ts
var import_view = require("@codemirror/view");
var EditorListener = class _EditorListener {
  static setState(state) {
    _EditorListener.state = state;
  }
  constructor(view) {
    this.view = view;
    view.dom.addEventListener("keydown", _EditorListener.state.handleKeyPress, true);
  }
  destroy() {
    this.view.dom.removeEventListener("keydown", _EditorListener.state.handleKeyPress, true);
  }
};
var initializeEditorListener = (state) => {
  EditorListener.setState(state);
  return import_view.ViewPlugin.fromClass(EditorListener);
};

// src/lib/trie.ts
var TrieNode = class {
  constructor() {
    this.children = {};
    this.isEndOfCommand = false;
  }
};
var CommandTrie = class {
  constructor() {
    this.root = new TrieNode();
  }
  /** Get command id for a prefix */
  getCommandId(prefix) {
    let current = this.root;
    for (const key of prefix) {
      if (!(key in current.children)) {
        return null;
      }
      current = current.children[key];
    }
    return current.id || null;
  }
  /** Get all possible completions for a prefix */
  getPossibleCommands(prefix) {
    let current = this.root;
    if (prefix == null ? void 0 : prefix.length) {
      for (const key of prefix) {
        if (!(key in current.children)) {
          return [];
        }
        current = current.children[key];
      }
    }
    const possibilities = [];
    Object.entries(current.children).forEach(([key, node]) => {
      possibilities.push({
        key,
        command: {
          name: node.name || "",
          id: node.id,
          icon: node.icon
        }
      });
    });
    return possibilities;
  }
  /**
   * Insert a command into the trie
   * @param name - Command name
   * @param id - Command id
   * @param icon - Command icon
   * @param prefix - Command prefix
   */
  insertCommand({
    name,
    id,
    icon,
    prefix
  }) {
    let current = this.root;
    if (prefix) {
      for (const key of prefix) {
        if (!(key in current.children)) {
          current.children[key] = new TrieNode();
        }
        current = current.children[key];
      }
    }
    current.name = name;
    current.id = id;
    current.icon = icon;
    current.isEndOfCommand = !!id;
  }
};

// src/settings/settings-tab.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  categorizedCommands: false
};

// src/state/shared-state.ts
var import_obsidian2 = require("obsidian");

// src/utils/constants.ts
var KEYS = {
  SPACE: " ",
  SHIFT: "Shift",
  CTRL: "Control",
  ALT: "Alt",
  META: "Meta",
  ENTER: "Enter",
  TAB: "Tab",
  ESCAPE: "Escape",
  BACKSPACE: "Backspace",
  FORWARD_SLASH: "/",
  PIPE: "|",
  DASH: "-"
};
var intentRegexes = {
  a: /^(?!.*(canvas|vault|toggle-ribbon|app:go)).*(app|audio|slides|publish|workspace:copy)/,
  b: /bookmarks/,
  c: /canvas/,
  d: /daily-notes/,
  f: /^(?!.*canvas).*(file|attach|template|export-pdf|show-trash|zk-prefixer)/,
  g: /^(?!.*editor).*graph/,
  i: /insert/,
  l: /link/,
  m: /markdown|properties/,
  n: /(?:app:go-(?:back|forward)|outline)/,
  s: /^(?!.*bookmark).*(search|switcher|command-palette)/,
  S: /sync/,
  t: /(?=.*editor)(?=.*toggle)|heading|cycle-list-checklist|swap-line|add-cursor|delete-paragraph|context-menu|fold|formatting/,
  T: /table/,
  Tab: /^(?!.*(table|tag)).*(tab|pane|pin|workspace:close|editor:focus)/,
  u: /theme/,
  v: /vault/,
  w: /window|workspaces|sidebar|split|toggle-ribbon|tag-pane|outline/,
  W: /webviewer/
};
var topLevelMappings = [
  {
    prefix: [KEYS.SPACE],
    name: "Open Quick Switcher",
    id: "switcher:open",
    icon: "square-chevron-right"
  },
  {
    prefix: [KEYS.FORWARD_SLASH],
    name: "Open Global Search",
    id: "global-search:open",
    icon: "globe"
  },
  {
    prefix: ["e"],
    name: "Toggle left sidebar",
    id: "app:toggle-left-sidebar",
    icon: "panel-left"
  },
  {
    prefix: ["p"],
    name: "Open command palette",
    id: "command-palette:open",
    icon: "square-terminal"
  },
  {
    prefix: [KEYS.PIPE],
    name: "Split right",
    id: "workspace:split-vertical",
    icon: "separator-vertical"
  },
  {
    prefix: [KEYS.DASH],
    name: "Split down",
    id: "workspace:split-horizontal",
    icon: "separator-horizontal"
  }
];
var intentMappings = [
  {
    prefix: ["a"],
    name: "App",
    id: void 0,
    icon: "dock",
    pattern: intentRegexes.a
  },
  {
    prefix: ["b"],
    name: "Bookmarks",
    id: void 0,
    icon: "bookmark",
    pattern: intentRegexes.b
  },
  {
    prefix: ["c"],
    name: "Canvas",
    id: void 0,
    icon: "brush",
    pattern: intentRegexes.c
  },
  {
    prefix: ["d"],
    name: "Daily Notes",
    id: void 0,
    icon: "calendar",
    pattern: intentRegexes.d
  },
  {
    prefix: ["f"],
    name: "File",
    id: void 0,
    icon: "file",
    pattern: intentRegexes.f
  },
  {
    prefix: ["g"],
    name: "Graph",
    id: void 0,
    icon: "brain-circuit",
    pattern: intentRegexes.g
  },
  {
    prefix: ["i"],
    name: "Insert",
    id: void 0,
    icon: "between-horizontal-start",
    pattern: intentRegexes.i
  },
  {
    prefix: ["l"],
    name: "Links",
    id: void 0,
    icon: "link",
    pattern: intentRegexes.l
  },
  {
    prefix: ["m"],
    name: "Markdown",
    id: void 0,
    icon: "a-large-small",
    pattern: intentRegexes.m
  },
  {
    prefix: ["n"],
    name: "Navigate",
    id: void 0,
    icon: "navigation",
    pattern: intentRegexes.n
  },
  {
    prefix: ["s"],
    name: "Search",
    id: void 0,
    icon: "search",
    pattern: intentRegexes.s
  },
  {
    prefix: ["S"],
    name: "Sync",
    id: void 0,
    icon: "folder-sync",
    pattern: intentRegexes.S
  },
  {
    prefix: ["t"],
    name: "Text",
    id: void 0,
    icon: "text",
    pattern: intentRegexes.t
  },
  {
    prefix: ["T"],
    name: "Table",
    id: void 0,
    icon: "table",
    pattern: intentRegexes.T
  },
  {
    prefix: [KEYS.TAB],
    name: "Tab navigation",
    id: void 0,
    icon: "arrow-right-to-line",
    pattern: intentRegexes.Tab
  },
  {
    prefix: ["u"],
    name: "UI",
    id: void 0,
    icon: "palette",
    pattern: intentRegexes.u
  },
  {
    prefix: ["v"],
    name: "Vault",
    id: void 0,
    icon: "vault",
    pattern: intentRegexes.v
  },
  {
    prefix: ["w"],
    name: "Windows",
    id: void 0,
    icon: "app-window",
    pattern: intentRegexes.w
  },
  {
    prefix: ["W"],
    name: "Webviewer",
    id: void 0,
    icon: "globe",
    pattern: intentRegexes.W
  }
];

// src/state/shared-state.ts
var SharedState = class {
  constructor(app, commandTrie, ui) {
    this.currentKeySequence = [];
    this.isRecording = false;
    this.insertMode = false;
    /**
     * Intercept key presses, preventing default behavior
     * @param event - Keyboard event
     */
    this.interceptKeyPress = (event) => {
      event.preventDefault();
      event.stopPropagation();
    };
    /**
     * Handles key presses in the editor. Prevents Tab, Space, etc while recording
     * @param event - Keyboard event
     */
    this.handleKeyPress = (event) => {
      var _a, _b, _c, _d;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      const editorHasFocus = activeView == null ? void 0 : activeView.editor.hasFocus();
      const isVimMode = (_d = (_c = (_b = (_a = activeView == null ? void 0 : activeView.editor) == null ? void 0 : _a.cm) == null ? void 0 : _b.cm) == null ? void 0 : _c.state) == null ? void 0 : _d.vim;
      const isInsertMode = isVimMode == null ? void 0 : isVimMode.insertMode;
      if (this.isRecording) {
        this.updateKeySequence(event);
      } else if (isVimMode && !isInsertMode && editorHasFocus && event.key === KEYS.SPACE) {
        this.startRecording();
        this.interceptKeyPress(event);
      }
    };
    this.app = app;
    this.commandTrie = commandTrie;
    this.ui = ui;
  }
  /**
   * Update the active command trie
   * @param commandTrie - The command trie
   */
  updateCommandTrie(commandTrie) {
    this.commandTrie = commandTrie;
  }
  /**
   * Start recording key presses
   */
  startRecording() {
    this.isRecording = true;
    this.currentKeySequence = [];
    const commands = this.commandTrie.getPossibleCommands();
    this.ui.showCommands(commands);
  }
  /**
   * Stop recording key presses, reset relevant state
   */
  stopRecording() {
    this.isRecording = false;
    this.currentKeySequence = [];
    this.ui.hideCommands();
  }
  /**
   * Update the key sequence array & execute if possible
   * @param event - Keyboard event
   */
  updateKeySequence(event) {
    const { key } = event;
    if (key === KEYS.ESCAPE) {
      this.stopRecording();
      return;
    }
    if (key === KEYS.SHIFT) return;
    this.interceptKeyPress(event);
    this.currentKeySequence.push(key);
    const commands = this.commandTrie.getPossibleCommands(this.currentKeySequence);
    this.ui.showCommands(commands, this.currentKeySequence);
    const commandId = this.commandTrie.getCommandId(this.currentKeySequence);
    if (commandId) {
      this.app.commands.executeCommandById(commandId);
      this.stopRecording();
    } else if (commands.length === 0) {
      this.stopRecording();
    }
  }
};

// src/ui/which-key-ui.ts
var import_obsidian3 = require("obsidian");
var WhichKeyUI = class {
  constructor() {
    this.visible = false;
  }
  createContainer() {
    this.container = document.createElement("div");
    this.container.addClass("which-key-container", "dialog");
    const keyPressed = document.createElement("div");
    keyPressed.addClass("which-key-pressed");
    this.container.appendChild(keyPressed);
    const possibleCommands = document.createElement("div");
    possibleCommands.addClass("which-key-commands");
    this.container.appendChild(possibleCommands);
    document.body.appendChild(this.container);
  }
  /**
   * Display possible commands based on the key pressed
   * @param possibleCommands - Commands to show
   * @param keysPressed - Keys pressed
   */
  showCommands(possibleCommands, keysPressed) {
    keysPressed = keysPressed ? ["Leader", ...keysPressed] : ["Leader"];
    if (!this.container) {
      this.createContainer();
    }
    this.container.style.display = "block";
    this.visible = true;
    const title = this.container.querySelector(".which-key-pressed");
    if (title) {
      title.textContent = `${keysPressed.join(" \xBB ")}`;
    }
    const commandsEl = this.container.querySelector(".which-key-commands");
    if (commandsEl) {
      commandsEl.textContent = "";
      possibleCommands.forEach(({ key, command }) => {
        var _a;
        if (key === KEYS.SPACE) key = "\u2423";
        const lucideIcon = (_a = command == null ? void 0 : command.icon) == null ? void 0 : _a.replace("lucide-", "");
        const cmdEl = document.createElement("div");
        cmdEl.addClass("which-key-command");
        const prefixEl = document.createElement("span");
        const arrowEl = document.createElement("span");
        const iconEl = document.createElement("span");
        const nameEl = document.createElement("span");
        prefixEl.addClass("which-key-prefix");
        arrowEl.addClass("which-key-command-arrow");
        iconEl.addClass("which-key-command-icon");
        nameEl.addClass("which-key-name");
        prefixEl.textContent = key;
        nameEl.textContent = `${command.id ? "" : "+"}${command.name}`;
        cmdEl.appendChild(prefixEl);
        cmdEl.appendChild(arrowEl);
        (0, import_obsidian3.setIcon)(arrowEl, "arrow-right");
        cmdEl.appendChild(iconEl);
        if (lucideIcon) (0, import_obsidian3.setIcon)(iconEl, lucideIcon);
        cmdEl.appendChild(nameEl);
        commandsEl.appendChild(cmdEl);
      });
    }
  }
  hideCommands() {
    if (this.container) {
      this.container.style.display = "none";
      this.visible = false;
    }
  }
};

// src/utils/helpers.ts
function extractIdFirstLetters(id) {
  const idWithoutCategory = id.split(":").pop() || id;
  return idWithoutCategory.split("-").map((word) => {
    var _a;
    return ((_a = word[0]) == null ? void 0 : _a.toLowerCase()) || "";
  });
}
function extractNameFirstLetters(name) {
  const nameWithoutCategory = name.split(":").pop() || name;
  return nameWithoutCategory.trim().split(" ").filter((word) => word && word.match(/[a-zA-Z0-9]/)).map((word) => {
    var _a, _b;
    const number = (_a = word.match(/[0-9]/)) == null ? void 0 : _a[0];
    if (number) return number;
    return ((_b = word[0]) == null ? void 0 : _b.toLowerCase()) || "";
  });
}
function extractNameRemainingLetters(name) {
  const nameWithoutCategory = name.split(":").pop() || name;
  return nameWithoutCategory.trim().split(" ")[0].split("").slice(1).map((letter) => letter.toLowerCase()) || "";
}
function generateSortedPrefixes(prefixCounts, ascending = true) {
  return Object.entries(prefixCounts).sort(([, a], [, b]) => ascending ? a - b : b - a).flatMap(([prefix]) => [prefix, prefix.toUpperCase()]);
}
function assignPrefixesToCommands(context) {
  const { parentPrefix, commandBucket, prefixesToAssign, preferredPrefixes, fallbackPrefixes } = context;
  for (const prefixOptions of [preferredPrefixes, fallbackPrefixes]) {
    for (const prefix of prefixesToAssign) {
      for (let i = 0; i < commandBucket.length; i++) {
        if (commandBucket[i].prefix) continue;
        if (prefixOptions[i].has(prefix.toLowerCase())) {
          commandBucket[i].prefix = [...parentPrefix, prefix];
          prefixesToAssign.delete(prefix);
          break;
        }
      }
    }
  }
  return commandBucket;
}
function determinePrefixes(prefixArray, commandBucket) {
  const prefixCounts = {};
  const fallbackCounts = {};
  const preferredPrefixes = commandBucket.map((command) => {
    const { id, name } = command;
    const firstLetters = /* @__PURE__ */ new Set([...extractNameFirstLetters(name), ...extractIdFirstLetters(id)]);
    for (const letter of firstLetters) {
      prefixCounts[letter] = (prefixCounts[letter] || 0) + 1;
    }
    return firstLetters;
  });
  const fallbackPrefixes = commandBucket.map((command) => {
    const { name } = command;
    const fallbackFirstLetters = /* @__PURE__ */ new Set([...extractNameRemainingLetters(name)]);
    for (const letter of fallbackFirstLetters) {
      fallbackCounts[letter] = (fallbackCounts[letter] || 0) + 1;
    }
    return fallbackFirstLetters;
  });
  const sortedPreferredPrefixes = generateSortedPrefixes(prefixCounts);
  const sortedFallbackPrefixes = generateSortedPrefixes(fallbackCounts, false);
  const prefixesToAssign = /* @__PURE__ */ new Set([...sortedPreferredPrefixes, ...sortedFallbackPrefixes]);
  const updatedCommands = assignPrefixesToCommands({
    parentPrefix: prefixArray,
    commandBucket,
    prefixesToAssign,
    preferredPrefixes,
    fallbackPrefixes
  });
  return updatedCommands;
}
function shuckCommands(commands) {
  return Object.values(commands).map(({ name, id, icon, hotkeys }) => ({
    name,
    id,
    icon,
    hotkeys
  }));
}
function filterCommandsByIntent(commands, pattern) {
  return commands.filter((command) => pattern.test(command.id || ""));
}
function buildCommandTrie(commands, commandTrie) {
  commands.forEach((command) => {
    if (command.prefix) {
      commandTrie.insertCommand(command);
    }
  });
  return commandTrie;
}
function curateCommands(commands, topLevelMappings2, intentMappings2, commandTrie) {
  const curatedCommands = [...topLevelMappings2];
  for (const { prefix, name, pattern, icon } of intentMappings2) {
    const bucket = filterCommandsByIntent(commands, pattern);
    if (bucket.length > 0) {
      curatedCommands.push({ prefix, name, icon });
      curatedCommands.push(...determinePrefixes(prefix, bucket));
    }
  }
  const curatedIds = new Set(curatedCommands.map((command) => command.id));
  const remainingCommands = commands.filter((command) => !curatedIds.has(command.id));
  if (remainingCommands.length > 0) {
    const extraCommands = {
      prefix: ["x"],
      name: "Extras",
      id: void 0,
      icon: "circle-help"
    };
    curatedCommands.push(extraCommands);
    curatedCommands.push(...determinePrefixes(extraCommands.prefix, remainingCommands));
  }
  return buildCommandTrie(curatedCommands, commandTrie);
}
function createCategoryBuckets(commands) {
  return commands.reduce((buckets, command) => {
    var _a;
    const category = ((_a = command == null ? void 0 : command.id) == null ? void 0 : _a.split(":")[0]) || "";
    (buckets[category] = buckets[category] || []).push(command);
    return buckets;
  }, {});
}
function generateCategoryPrefixOptions(category) {
  const firstLetterOptions = category.split("-").flatMap((word) => [word[0].toLowerCase(), word[0].toUpperCase()]);
  const remainingLetters = category.split("-")[0].split("").slice(1).flatMap((letter) => [letter.toLowerCase(), letter.toUpperCase()]);
  return [...firstLetterOptions, ...remainingLetters];
}
function assignCategoryPrefixes(sortedCategories) {
  const categoryMappings = {};
  for (const [category, commands] of sortedCategories) {
    const prefixOptions = generateCategoryPrefixOptions(category);
    const formattedName = category.replace(/-/g, " ").replace(/^\w/, (c) => c.toUpperCase());
    for (const prefix of prefixOptions) {
      if (categoryMappings[prefix]) continue;
      categoryMappings[prefix] = {
        formattedName,
        commands
      };
      break;
    }
  }
  return categoryMappings;
}
function categorizeCommands(commands, commandTrie) {
  const categoryBuckets = createCategoryBuckets(commands);
  const sortedCategories = Object.entries(categoryBuckets).sort(([a], [b]) => a.localeCompare(b));
  const categoryMappings = assignCategoryPrefixes(sortedCategories);
  const categorizedCommands = [];
  for (const [prefix, { formattedName, commands: commands2 }] of Object.entries(categoryMappings)) {
    const prefixArray = [prefix];
    categorizedCommands.push({
      name: formattedName,
      prefix: prefixArray,
      id: void 0
    });
    categorizedCommands.push(...determinePrefixes(prefixArray, commands2));
  }
  return buildCommandTrie(categorizedCommands, commandTrie);
}

// src/main.ts
var WhichKey = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    /**
     * Handle key presses on the document when the editor is not focused
     * @param event - Keyboard event
     * @returns void
     */
    this.handleGlobalKeyPress = (event) => {
      var _a;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      const editorHasFocus = (_a = activeView == null ? void 0 : activeView.editor) == null ? void 0 : _a.hasFocus();
      if (editorHasFocus) {
        return;
      }
      if (this.state.isRecording) {
        this.state.updateKeySequence(event);
      }
    };
  }
  async onload() {
    await this.loadSettings();
    const leanCommands = shuckCommands(this.app.commands.commands);
    this.curatedTrie = curateCommands(
      leanCommands,
      topLevelMappings,
      intentMappings,
      new CommandTrie()
    );
    this.categorizedTrie = categorizeCommands(leanCommands, new CommandTrie());
    const activeTrie = this.settings.categorizedCommands ? this.categorizedTrie : this.curatedTrie;
    this.state = new SharedState(this.app, activeTrie, new WhichKeyUI());
    this.registerEditorExtension(initializeEditorListener(this.state));
    document.addEventListener("keydown", this.handleGlobalKeyPress, true);
    this.addCommand({
      id: "open-which-key",
      name: "Open WhichKey",
      callback: () => this.state.startRecording()
    });
  }
  onunload() {
    document.removeEventListener("keydown", this.handleGlobalKeyPress, true);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const activeTrie = this.settings.categorizedCommands ? this.categorizedTrie : this.curatedTrie;
    this.state.updateCommandTrie(activeTrie);
  }
};
