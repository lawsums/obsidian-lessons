## 使用 shell commands
1. 直接将加入末尾
2. 将 cpp 文件复制到剪切板, 自己粘贴

---

## 使用 autocmd.lua
简化配置！去掉 MD 文件存在性检测，**只在 MD 已存在时同步，不存在则直接跳过**，代码更简洁高效：

### 最终 Lua 版本（推荐）
直接复制到 `init.lua`：
```lua
-- 保存 C++ 文件后，同步代码到同名 MD 的 Solution 区块（仅 MD 存在时生效）
local function sync_cpp_to_md()
  -- 1. 获取当前 C++ 文件的路径信息
  local cpp_dir = vim.fn.expand("%:p:h")  -- C++ 文件所在目录
  local cpp_name = vim.fn.expand("%:t:r") -- C++ 文件名（不带后缀）
  local md_path = cpp_dir .. "/" .. cpp_name .. ".md" -- 同名 MD 文件路径

  -- 2. 若 MD 文件不存在，直接退出（不操作）
  if vim.fn.filereadable(md_path) ~= 1 then
    return
  end

  -- 3. 读取 C++ 文件内容（trim 首尾空白）
  local cpp_content = vim.fn.readfile(vim.fn.expand("%:p"), "b")
  cpp_content = table.concat(cpp_content, "\n"):gsub("^%s+", ""):gsub("%s+$", "")
  if cpp_content == "" then
    vim.notify("[Sync] C++ 文件为空，跳过同步", vim.log.levels.WARN)
    return
  end

  -- 4. 读取 MD 文件内容，替换 Solution 区块
  local md_content = vim.fn.readfile(md_path, "b")
  md_content = table.concat(md_content, "\n")

  -- 正则匹配：## Solution → END 之间的内容（保留前后标签）
  local solution_pattern = "(## Solution\n\n)([%s%S]*?)(\nEND)"
  local updated_md = md_content:gsub(solution_pattern, function(prefix, _, suffix)
    return prefix .. "```cpp\n" .. cpp_content .. "\n```" .. suffix
  end)

  -- 5. 替换成功则写入 MD 文件
  if updated_md ~= md_content then
    vim.fn.writefile(vim.split(updated_md, "\n"), md_path, "b")
    vim.notify("[Sync] 代码已同步到：" .. md_path, vim.log.levels.INFO)
  end
end

-- 配置 autocmd：保存 .cpp 文件时触发
vim.api.nvim_create_autocmd("BufWritePost", {
  pattern = "*.cpp", -- 所有 .cpp 文件生效（可按需限制目录，如 "E:/xxx/Leetcode/*.cpp"）
  callback = sync_cpp_to_md,
  desc = "保存 C++ 文件后，同步代码到同名 MD 的 Solution 区块（仅 MD 存在时）",
})
```

### Vimscript 版本（适配 init.vim）
```vimscript
function! SyncCppToMd() abort
  " 1. 获取文件路径信息
  let cpp_dir = expand("%:p:h")
  let cpp_name = expand("%:t:r")
  let md_path = cpp_dir . "/" . cpp_name . ".md"

  " 2. MD 不存在则退出
  if filereadable(md_path) ~= 1
    return
  endif

  " 3. 读取 C++ 内容（trim 首尾）
  let cpp_content = readfile(expand("%:p"), "b")
  let cpp_content = join(cpp_content, "\n")
  let cpp_content = substitute(cpp_content, '^\s\+', '', '')
  let cpp_content = substitute(cpp_content, '\s\+$', '', '')
  if cpp_content == ""
    echom "[Sync] C++ 文件为空，跳过同步"
    return
  endif

  " 4. 替换 MD 中 Solution 区块
  let md_content = readfile(md_path, "b")
  let md_content = join(md_content, "\n")
  let solution_pattern = '\(## Solution\n\n\)\(.\{-}\)\(\nEND\)'
  let updated_md = substitute(md_content, solution_pattern, '\1```cpp\n' . cpp_content . '\n```\3', '')

  " 5. 写入更新后的 MD
  if updated_md != md_content
    call writefile(split(updated_md, "\n"), md_path, "b")
    echom "[Sync] 成功同步到 MD：" . md_path
  endif
endfunction

" 配置 autocmd
autocmd BufWritePost *.cpp call SyncCppToMd()
```

### 核心变更
1. 移除了 MD 文件创建逻辑，**仅当 MD 已存在时才执行同步**
2. 精简代码：删除不必要的提示（MD 不存在时静默跳过，不弹窗/不输出日志）
3. 保留核心功能：同步 C++ 代码到 MD 的 `## Solution` → `END` 区块，自动包裹 cpp 代码块

### 使用方式
1. 确保 MD 文件和 C++ 文件 **同目录、同名**（如 `896.xxx.cpp` ↔ `896.xxx.md`）
2. 在 Neovim 中编辑 C++ 文件，按 `:w` 保存
3. 自动同步代码到 MD 的 Solution 区块（无任何手动操作）

### 可选优化（按需添加）
若想只对特定目录（如 Leetcode 目录）的 C++ 文件生效，修改 `pattern`：
```lua
-- Lua 版本：仅同步 Leetcode 目录下的 cpp 文件
vim.api.nvim_create_autocmd("BufWritePost", {
  pattern = "E:/Documents/Obsidian/Leetcode/*.cpp", -- 替换为你的 MD 存放目录
  callback = sync_cpp_to_md,
})
```

```vimscript
" Vimscript 版本：仅同步特定目录
autocmd BufWritePost E:/Documents/Obsidian/Leetcode/*.cpp call SyncCppToMd()
```