
DECK: 面试题

## 最小栈和单调栈和单调队列的区别


## 标准答案
最小栈、单调栈、单调队列的核心区别在于 **设计目标、数据结构特性、适用场景** 完全不同——前两者是「栈结构」，后者是「队列结构」，且单调栈/队列的核心是「维护单调性」，最小栈的核心是「快速获取最小值」。

用一张表先明确三者的核心差异：

| 特性          | 最小栈（MinStack）               | 单调栈（Monotonic Stack）                                                        | 单调队列（Monotonic Queue）                        |
| ----------- | --------------------------- | --------------------------------------------------------------------------- | -------------------------------------------- |
| **核心目标**    | 快速获取栈内最小值（O(1) 时间）          | 维护栈内元素单调性（递增/递减），解决「Next Greater Element」等问题                                | 维护队列内元素单调性（递增/递减），解决「滑动窗口最值」等问题              |
| **数据结构基础**  | 栈（通常用双栈实现：数据栈+最小栈）          | 栈（仅用一个栈，入栈时维护单调性）                                                           | 队列（通常用双端队列 Deque 实现）                         |
| **元素关系**    | 无强制单调性，仅记录「当前最小值」           | 严格单调递增/递减（允许相等与否看场景）                                                        | 严格单调递增/递减（允许相等与否看场景）                         |
| **主要操作复杂度** | push/pop/top/getMin 均 O(1)  | 每个元素入栈/出栈各 1 次，整体 O(n)                                                      | 每个元素入队/出队各 1 次，整体 O(n)                       |
| **典型应用**    | 实时获取栈内最小值（如 LeetCode 155 题） | 1. 下一个更大/更小元素（LeetCode 496/503）；2. 接雨水（LeetCode 42）；3. 柱状图最大矩形（LeetCode 84） | 1. 滑动窗口最大值/最小值（LeetCode 239）；2. 滑动窗口内的最值相关问题 |


### 一、最小栈：「栈 + 最小值索引/副本」，专注快速查最小
最小栈的核心是 **“在普通栈的基础上，额外记录最小值”**，不要求栈内元素有序，仅保证「随时能拿到当前栈的最小值」。

#### 实现逻辑（以你之前的双栈实现为例）：
- 数据栈（stk）：存储原始元素，正常 push/pop；
- 最小栈（min_stack）：仅存储「当前阶段的最小值」——push 时新元素≤栈顶才入栈，pop 时若数据栈顶等于最小栈顶则同步 pop。
- 本质：用额外空间换 O(1) 查最小值的效率，栈内元素无单调性（比如你之前的测试用例：数据栈 [-2,0,-3]，并非单调）。

#### 关键特点：
- 不维护整体单调性，只关注「最小值」这一个特殊值；
- 操作均为栈的标准操作（仅在 push/pop 时加简单判断）；
- 场景单一：仅用于需要「实时获取栈内最小值」的场景，无其他延伸用途。


### 二、单调栈：「栈 + 强制单调性」，专注“前后元素关系”
单调栈的核心是 **“栈内元素必须保持严格递增/递减”**，通过「入栈时弹出破坏单调性的元素」来维护这个规则。它不关心“最小值”，而是关心「每个元素的下一个更大/更小元素」——这是最小栈做不到的。

#### 实现逻辑（以“单调递减栈”为例）：
- 入栈时：如果新元素 > 栈顶元素，说明栈顶元素的「下一个更大元素」就是新元素，弹出栈顶并记录结果，重复此过程直到栈顶≥新元素，再将新元素入栈；
- 出栈时：仅在入栈时被动弹出（为了维护单调性），不主动出栈；
- 本质：用栈的“后进先出”特性，高效找到每个元素的「最近相关元素」（如next greater），栈内元素严格有序。

#### 关键特点：
- 核心是「单调性」，而非“最值”（虽然单调栈的栈顶是当前栈的最值，但这是副产品，不是设计目标）；
- 场景聚焦：解决“元素前后关系”问题（如下一个更大元素、区间最值、柱状图面积等）；
- 每个元素仅入栈/出栈一次，时间复杂度 O(n)，效率极高。

#### 例子（LeetCode 496. 下一个更大元素 I）：
输入 [2,1,3]，单调递减栈过程：
1. 2 入栈 → 栈 [2]；
2. 1 < 2，入栈 → 栈 [2,1]；
3. 3 > 1 → 弹出 1，记录 1 的下一个更大元素是 3；
4. 3 > 2 → 弹出 2，记录 2 的下一个更大元素是 3；
5. 3 入栈 → 栈 [3]；
最终结果 [3,3,-1]——这是最小栈完全无法实现的功能。


### 三、单调队列：「队列 + 强制单调性」，专注“滑动窗口最值”
单调队列的核心是 **“队列内元素必须保持严格递增/递减”**，但基于「队列（双端队列）」实现，支持两端插入/删除，核心用于「滑动窗口场景」——快速获取窗口内的最值。

#### 实现逻辑（以“滑动窗口最大值”为例，单调递减队列）：
- 入队时：如果新元素 ≥ 队尾元素，说明队尾元素不可能成为后续窗口的最大值，弹出队尾，重复此过程直到队尾>新元素，再将新元素从队尾入队；
- 出队时：如果窗口移除的元素是队首元素（当前最大值），则队首出队（保证队列内元素都在当前窗口内）；
- 本质：用双端队列维护「窗口内的候选最值元素」，队列内元素严格递减，队首始终是当前窗口的最大值。

#### 关键特点：
- 基于队列结构，支持两端操作（区别于单调栈的仅栈顶操作）；
- 核心场景：滑动窗口的最值问题（如 LeetCode 239. 滑动窗口最大值），这是最小栈和单调栈都难以高效实现的；
- 同样维护单调性，但应用场景和数据结构基础与单调栈完全不同。

#### 例子（滑动窗口最大值 [1,3,-1,-3,5,3,6,7]，窗口大小 3）：
- 窗口 [1,3,-1]：队列 [3,-1] → 最大值 3；
- 窗口 [3,-1,-3]：队列 [3,-1,-3] → 最大值 3；
- 窗口 [-1,-3,5]：弹出所有元素，队列 [5] → 最大值 5；
- 后续窗口以此类推，队首始终是窗口最大值，时间复杂度 O(n)。


### 四、核心区别总结（避免混淆）
1. **与“单调性”的关系**：
   - 最小栈：不维护单调性，仅记录最小值；
   - 单调栈/队列：核心是「单调性」，所有操作都是为了维持这个特性。

2. **数据结构基础**：
   - 最小栈/单调栈：栈结构（后进先出）；
   - 单调队列：队列结构（先进先出，双端操作）。

3. **适用场景**：
   - 最小栈：仅用于「实时获取栈内最小值」；
   - 单调栈：用于「元素前后关系」（下一个更大/更小元素、区间最值）；
   - 单调队列：用于「滑动窗口最值」。

4. **一个直观对比**：
   - 用最小栈无法解决“下一个更大元素”问题（因为元素无序）；
   - 用单调栈无法实时获取栈内最小值（比如单调递增栈，栈底是最小值，但 pop 后需要重新找，无法 O(1)）；
   - 用单调队列无法替代单调栈（队列的先进先出不适合“前后元素关系”问题）。


### 一句话记忆
- 要「栈的最小值」→ 最小栈；
- 要「元素的前后相关元素」→ 单调栈；
- 要「滑动窗口的最值」→ 单调队列。

## 我的答案



END
<!--ID: 1768379909697-->
