---
Date: 2026-01-11
Link: https://leetcode.com/problems/multiply-strings/
Category: 
- 数学
- 字符串
- 模拟
Difficulty: Medium
Completed: false
---

#数学 #字符串 #模拟 
<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5C%E8%AE%BA%E6%96%87%5CLeetcode%5C43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 43. 字符串相乘

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

**示例 1:**

**输入:** num1 = "2", num2 = "3"
**输出:** "6"

**示例 2:**

**输入:** num1 = "123", num2 = "456"
**输出:** "56088"

**提示：**

- `1 <= num1.length, num2.length <= 200`
- `num1` 和 `num2` 只能由数字组成。
- `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。

## Notes
1. 反转字符串,  预留答案数组
2. 使用双重循环进行**交错乘法**, 把每一位放在对应的位数上相加
3. 一起处理进位
4. 反转回来, **去除前缀零**

## Solution 
```csharp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // 功能：实现两个非负整数字符串的乘法（避免整数溢出，适用于超大数）
    // 参数：num1 - 第一个整数的字符串形式，num2 - 第二个整数的字符串形式
    // 返回值：两个数相乘结果的字符串形式
    string multiply(string num1, string num2) {
        // 边界条件：任一数为"0"，乘积直接返回"0"（避免后续无效计算）
        if (num1 == "0" || num2 == "0") return "0"; 

        // 反转字符串：将数字从"高位在前"转为"低位在前"，方便按位相乘（从个位开始计算）
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());

        int n = num1.size();  // 第一个数的位数（反转后仍为原位数）
        int m = num2.size();  // 第二个数的位数
        // ans数组：存储每一位的乘积和+进位结果，初始化为0
        // 大小设为n+m+1：两个数相乘的最大位数为n+m（如999*999=998001，3+3=6位），+1预留最终进位空间
        vector<int> ans(n + m + 1, 0); 

        // 第一步：计算所有位的乘积和（不立即处理进位，先累加对应位的乘积）
        // 原理：num1的第i位（原个位为i=0）与num2的第j位相乘，结果落在最终结果的第i+j位
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // num1[i]-'0'：将字符形式的数字转为整数
                // 乘积累加到ans[i+j]：同一位置的所有乘积求和（后续统一处理进位）
                ans[i + j] += (num1[i] - '0') * (num2[j] - '0');
            }
        }

        // 第二步：统一处理所有位的进位（从低位到高位）
        int carry = 0;  // 记录当前位向高位的进位值
        for (int i = 0; i < ans.size(); i++) {
            ans[i] += carry;       // 加上上一位传递过来的进位
            carry = ans[i] / 10;   // 计算当前位的新进位（除以10取商）
            ans[i] = ans[i] % 10;  // 保留当前位的有效数字（除以10取余）
        }

        // 第三步：将ans数组的整数转为字符（0->'0'，1->'1'...）
        for (int i = 0; i < ans.size(); i++) {
            ans[i] += '0';  // 利用ASCII码偏移：'0'的ASCII是48，整数+48即为对应字符
        }

        // 第四步：反转ans数组，恢复"高位在前"的正常数字顺序
        // （ans原本是低位在前，反转后变为高位在前，如[8,0,8,6,5]→"56808"）
        string res = string(ans.rbegin(), ans.rend());

        // 第五步：去除结果字符串的前导零（反转后可能存在多余的前导零）
        int idx = 0;
        while (idx < res.size() && res[idx] == '0') {
            idx++;  // 找到第一个非零字符的位置
        }

        // 返回去除前导零后的结果（idx不会等于res.size()，因为前面已处理0的情况）
        return res.substr(idx);  
    }
};

```


![[43. 字符串相乘.cpp]]


END
<!--ID: 1768203109022-->


