---
Date: 2026-02-03
Link: https://leetcode.com/problems/find-all-anagrams-in-a-string/
Category: 
- 哈希表
- 字符串
- 滑动窗口
Difficulty: Medium
SimilarQuestions:  
- 有效的字母异位词
- 字符串的排列
Completed: false
---

#哈希表 #字符串 #滑动窗口 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 438. 找到字符串中所有字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1:**

**输入:** s = "cbaebabacd", p = "abc"
**输出:** [0,6]
**解释:**
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

 **示例 2:**

**输入:** s = "abab", p = "ab"
**输出:** [0,1,2]
**解释:**
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

## Notes
这题主要考虑:
- 欠债模型中为什么不需要考虑 cnt 是否大于零?

## Solution 

![[438. 找到字符串中所有字母异位词.cpp]]

```cpp  
#include <bits/stdc++.h>
#include <unordered_map>
using namespace std;

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        return f1(s, p);
    }

    // 哈希表遍历
    vector<int> f1(string s, string p) {
        unordered_map<int, vector<int>> mp; 

        int n = s.size(), m = p.size();
        vector<int> path(26, 0);
        // 初始化
        mp[-1] = path;

        // 构建p的词频
        vector<int> p_cnt(26, 0);
        for (auto c : p) {
            p_cnt[c - 'a']++;
        }

        // 构造前缀和, 更新答案
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            path[s[i] - 'a']++;
            mp[i] = path;
            if (i >= m - 1) {
                if (check(mp, i, p, p_cnt)) ans.push_back(i - m + 1);
            }
        }

        return ans;
    }

private:
    bool check(unordered_map<int, vector<int>> &mp, int id, string &p, vector<int> &p_cnt) {
        int m = p.size();
        vector<int> cur = mp[id], pre = mp[id - m];
        // 检测词频是否相同
        for (int i = 0; i < 26; i++) {
            if (cur[i] - pre[i] != p_cnt[i]) return false; 
        }
        return true;
    }

// TODO 这里的欠债为什么不要考虑cnt里面是否大于0, 我记得有的题目里面好像要考虑
// ANS: 
// 一、先明确：这道题的「欠债模型」核心逻辑
// 这道题是找异位词，本质要求是：窗口内的字符种类、数量，和 p 完全一致（不多、不少、不差）。我们定义的cnt[26]是 **「字符的供需差值」**，核心含义：
// cnt[i] > 0：字符i+'a'缺这么多个（p 需要，但窗口里不够）
// cnt[i] < 0：字符i+'a'多这么多个（窗口里有，但 p 不需要 / 多出来了）
// cnt[i] = 0：字符i+'a'供需平衡（窗口里的数量和 p 完全一致）
// 所以当 cnt 全为 0 时，窗口就是 p 的异位词—— 这是这道题的核心结论，也是为什么不需要单独判断 cnt>0的原因：
// 全 0 的条件已经同时包含了「不缺（无 cnt>0）」和「不多（无 cnt<0）」，单独判断反而多余。
// 你代码里f2的逻辑是完全正确的，测试用例s="cbaebabacd", p="abc"会正确输出[0,6]。
// 二、关键：什么时候需要判断cnt>0？
// 需要判断cnt>0的场景，是另一类和异位词相似但要求不同的题目：找字符串中包含 p 所有字符的子串 / 子序列（即「最小覆盖子串」问题）。比如力扣 76 题「最小覆盖子串」：要求找到 s 中包含 p 所有字符（数量也匹配）的最短子串，此时窗口的要求是：
// 窗口内的字符，对于 p 需要的字符，数量必须≥p 的数量（可以多，不能少）
// 其他字符可以任意多
// 此时我们的欠债模型会做优化：只统计「缺的字符数」，此时需要判断cnt[i] > 0（表示还缺这个字符）
public:
    // 欠债模型
    vector<int> f2(string s, string p) {
        int n = s.size(), m = p.size();
        vector<int> ans;
        if (n < m) return ans;

        vector<int> cnt(26, 0); 
        // 首先欠债
        for (int i = 0; i < m; i++) {
            cnt[p[i] - 'a']++;
            cnt[s[i] - 'a']--;
        }

        auto all_zero = [](const vector<int> &arr) { 
            return all_of(arr.begin(), arr.end(), [](int a) { return a == 0; });
        };
                
        if (all_zero(cnt)) ans.push_back(0);

        for (int i = m; i < n; i++) {
            cnt[s[i] - 'a']--;
            cnt[s[i - m] - 'a']++;
            if (all_zero(cnt)) ans.push_back(i - m + 1);
        }

        return ans;
    }
};

```  
END 
