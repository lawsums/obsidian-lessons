---
Date: 2026-01-19
Link: https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/
Category: 
- 数组
- 二分查找
- 矩阵
- 前缀和
Difficulty: Medium
SimilarQuestions:  
Completed: false
---

#数组 #二分查找 #矩阵 #前缀和 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5C%E8%AE%A1%E7%BD%91%5CLeetcode%5C1413.%20%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 1413. 元素和小于等于阈值的正方形的最大边长

给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。

请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 **0** 。  
 

**示例 1：**

![](images/1413_e1.png)

**输入：**mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4
**输出：**2
**解释：**总和小于或等于 4 的正方形的最大边长为 2，如图所示。

**示例 2：**

**输入：**mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1
**输出：**0

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 300`
- `0 <= mat[i][j] <= 104`
- `0 <= threshold <= 105`

## Notes


## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxSideLength(vector<vector<int>>& grid, int threshold) {
        return f2(grid, threshold);
    }

    // 普通前缀和
    int f1(vector<vector<int>>& grid, int threshold) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        auto pre = vector<vector<int>>(n, vector<int>(m, 0));

        // 构造二维前缀和
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                pre[i][j] = grid[i][j] + get(pre, i - 1, j) + get(pre, i, j - 1) - get(pre, i - 1, j - 1);
            }
        }

        // 对于每个位置进行判断是否有更大的正方形
        for (int i = 0; i < n; i++) { 
            for (int j = 0; j < m; j++) {
                for (int k = min(i, j) + 1; k > ans; k--) {
                    if (pre[i][j] - get(pre, i - k, j) - get(pre, i, j - k) + get(pre, i - k, j - k) <= threshold) {
                        ans = k;
                    }
                }
            }
        }

        return ans; // 返回边长而不是面积
    }

    // 二分搜索法
    int f2(vector<vector<int>>& grid, int threshold) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        vector<vector<int>> pre(n + 1, vector<int>(m + 1, 0)); // 前缀和数组多开1行1列，避免边界判断

        // 构造二维前缀和（更简洁的写法，无需get函数）
        for (int i = 1; i <= n; i++) {
            int row_sum = 0;
            for (int j = 1; j <= m; j++) {
                row_sum += grid[i-1][j-1];
                pre[i][j] = pre[i-1][j] + row_sum;
            }
        }

        // 二分查找最大边长：全局范围是 [0, max_len]，max_len是网格能容纳的最大正方形边长
        int max_possible_len = min(n, m);
        int left = 0, right = max_possible_len;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (hasValidSquare(pre, n, m, mid, threshold)) {
                ans = mid;       // 找到合法边长，尝试更大的
                left = mid + 1;
            } else {
                right = mid - 1; // 边长太大，尝试更小的
            }
        }

        return ans;
    }

private:
    int get(vector<vector<int>> &grid, int i, int j) {
        if (i < 0 || j < 0) return 0;
        return grid[i][j];
    }

    // 检查是否存在边长为k的正方形，其和 ≤ threshold
    bool hasValidSquare(vector<vector<int>>& pre, int n, int m, int k, int threshold) {
        if (k == 0) return true; // 边长为0必然合法
        // 遍历所有可能的k*k正方形（右下角顶点为(i,j)）
        for (int i = k; i <= n; i++) {
            for (int j = k; j <= m; j++) {
                // 计算正方形的和：前缀和公式（避免边界判断，因为pre多开了1行1列）
                int sum = pre[i][j] - pre[i - k][j] - pre[i][j - k] + pre[i - k][j - k];
                if (sum <= threshold) {
                    return true;
                }
            }
        }
        return false;
    }
};


```



![[1413. 元素和小于等于阈值的正方形的最大边长.cpp]]


END
<!--ID: 1768795441487-->


