---
Date: 2026-01-04
Link: https://leetcode.com/problems/network-delay-time/
Category: 
Difficulty: Medium
Completed: false
---


<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5C%E8%AE%A1%E7%BD%91%5CLeetcode%5C744.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 744. 网络延迟时间

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

**示例 1：**

![](images/744_931_example_1.png)

**输入：**times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
**输出：**2

**示例 2：**

**输入：**times = [[1,2,1]], n = 2, k = 1
**输出：**1

**示例 3：**

**输入：**times = [[1,2,1]], n = 2, k = 2
**输出：**-1

**提示：**

- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）

## Notes
使用一个**小根堆**判别当前选取的最小边
使用一个 bool 数组用来判断当前节点**是否被访问过**
==后面是这道题的要求，正常情况下我们需要的就是 s 到 n 的距离就是 `distance[n]`，或者说你需要路径的话, 就是要添加一个数组 path, 在每次更新距离的时候加入一句 `path[v] = u`, 表示路径是从 u 那里继承过来的==

## Solution 
```cpp
#include <bits/stdc++.h>
#include <climits>
#include <queue>
using namespace std;

typedef array<int, 2> aii;

// Dijkstra算法模版
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int s) {
        vector<vector<aii>> graph(n + 1, vector<aii>());
        for (const auto &edge : times) {
            graph[edge[0]].push_back({edge[1], edge[2]}); 
        }

        vector<int> distance(n + 1, INT_MAX);
        vector<bool> visited(n + 1, false);
        distance[s] = 0; // 初始自己的距离是0

        auto cmp = [](aii& a, aii& b) { return a[1] > b[1]; }; // 小根堆
        priority_queue<aii, vector<aii>, decltype(cmp)> pq(cmp);

        // 将初始的s加入pq, 距离为零
        pq.push({s, 0});
        while (!pq.empty()) {
            int u = pq.top()[0]; pq.pop(); // 自动选取权值最小的边
            if (visited[u]) {
                continue;
            }
            visited[u] = true;

            for (const auto &edge : graph[u]) {
                auto [v, w] = edge;
                if (!visited[v] && distance[u] + w < distance[v]) { // 如果值更小的话就更新
                    distance[v] = distance[u] + w; // 说明s到u再到v的路径比原先到v的路径更短
                    pq.push({v, distance[v]});
                }
            }
        }

		// 后面是这道题的要求，正常情况下我们需要的就是s到n的距离就是distance[n]，或者说你需要路径的话, 就是要添加一个数组path, 在每次更新距离的时候加入一句path[v] = u, 表示路径是从u那里继承过来的
        int ans = INT_MIN;
        // 寻找所有点中的距离最大值
        for (int i = 1; i <= n; i++) {
            if (distance[i] == INT_MAX) {
                return -1;
            }
            ans = max(ans, distance[i]);
        }
        return ans;
    }
};


```



![[744. 网络延迟时间.cpp]]


END
<!--ID: 1767522704342-->


