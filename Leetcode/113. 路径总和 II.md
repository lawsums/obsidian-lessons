---
Date: 2026-01-20
Link: https://leetcode.com/problems/path-sum-ii/
Category: 
- 树
- 深度优先搜索
- 回溯
- 二叉树
Difficulty: Medium
SimilarQuestions:  
- 路径总和
- 二叉树的所有路径
- 路径总和 III
- 路径总和 IV
- 从二叉树一个节点到另一个节点每一步的方向
Completed: false
---

#树 #深度优先搜索 #回溯 #二叉树 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 113. 路径总和 II

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![](images/113_pathsumii1.jpg)

**输入：**root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
**输出：**[[5,4,11,2],[5,8,4,5]]

**示例 2：**

![](images/113_pathsum2.jpg)

**输入：**root = [1,2,3], targetSum = 5
**输出：**[]

**示例 3：**

**输入：**root = [1,2], targetSum = 0
**输出：**[]

**提示：**

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

## Notes


## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {

};


// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};


class Solution {
public:
	vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        return f1(root, targetSum);
    }
    
private:
    vector<vector<int>> ans;
    vector<int> path;
    int targetSum;

public:
    vector<vector<int>> f1(TreeNode* root, int targetSum) {
        this->targetSum = targetSum;
        handler(root, 0);
        return ans;
    }

    void handler(TreeNode *node, int sum) {
        if (!node) return;
        sum += node->val;
        if (!node->left && !node->right) { // 如果是叶子节点
            if (sum == targetSum) {
                path.push_back(node->val); 
                ans.push_back(path);
                path.pop_back(); 
            }
            return;
        }

        // 传递给下一层节点，sum加上当前节点的值
        path.push_back(node->val); 
        handler(node->left, sum);
        path.pop_back(); 

        path.push_back(node->val); 
        handler(node->right, sum);
        path.pop_back(); 
    }
    
    // 0x3f
    vector<vector<int>> f2(TreeNode* root, int targetSum) {
        vector<vector<int>> ans;
        vector<int> path;

        auto dfs = [&](this auto&& dfs, TreeNode* node, int left) -> void {
            if (node == nullptr) {
                return;
            }
            path.push_back(node->val);
            left -= node->val;
            if (node->left == nullptr && node->right == nullptr && left == 0) {
                ans.push_back(path);
            } else {
                dfs(node->left, left);
                dfs(node->right, left);
            }
            path.pop_back(); // 恢复现场
        };

        dfs(root, targetSum);
        return ans;
    }
};
 
```


![[113. 路径总和 II.cpp]]


END
<!--ID: 1769078758545-->


