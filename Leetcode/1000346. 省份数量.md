---
Date: 2026-01-22
Link: https://leetcode.com/problems/bLyHh0/
Category: 
- 深度优先搜索
- 广度优先搜索
- 并查集
- 图
Difficulty: Medium
SimilarQuestions:  
Completed: false
---

#深度优先搜索 #广度优先搜索 #并查集 #图 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C1000346.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 1000346. 省份数量

有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1：**

![](images/1000346_graph1.jpg)

**输入：**isConnected = [[1,1,0],[1,1,0],[0,0,1]]
**输出：**2

**示例 2：**

![](images/1000346_graph2.jpg)

**输入：**isConnected = [[1,0,0],[0,1,0],[0,0,1]]
**输出：**3

**提示：**

- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` 为 `1` 或 `0`
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

注意：本题与主站 547 题相同： [https://leetcode.cn/problems/number-of-provinces/](https://leetcode.cn/problems/number-of-provinces/)

## Notes
这道题目做法很经典


## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        return f1(isConnected);
    }

    // 广度+深度优先搜索
    int f1(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        bool* visited = new bool[n]; 
        memset(visited, 0, sizeof(bool) * n);

        int ans = 0;
        for (int i = 0; i < n; i++) {
            // printf("ans = %d\n", ans);
            if (dfs(i, visited, isConnected)) ans++;
        }

        delete[] visited;
        return ans;
    }


    bool dfs(int i, bool *visited, vector<vector<int>> &isConnected) {
        if (visited[i]) return false; // 如果之前访问过了的话, 说明不算一个单独的省份
        visited[i] = true; // 先把自己置为true, 防止反复dfs自己
        for (int j = 0;  j < isConnected[i].size(); j++) {
            if (isConnected[i][j] == 1 && !visited[j]) {
                dfs(j, visited, isConnected);
            }
        }     
        return true;
    }

    // 方法1：DFS（使用lambda）
    int f2(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        if (n == 0) return 0;
        
        vector<bool> visited(n, false);
        int provinces = 0;
        
        // 使用lambda函数，捕获需要的局部变量
        function<void(int)> dfs = [&](int city) {
            visited[city] = true;
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (isConnected[city][neighbor] == 1 && !visited[neighbor]) {
                    dfs(neighbor);
                }
            }
        };
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i);
                provinces++;
            }
        }
        
        return provinces;
    }
	
	// 方法2：并查集实现
    int f3(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        if (n == 0) return 0;
        
        // 初始化并查集
        vector<int> parent(n);
        vector<int> rank(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        
        // 查找根节点（带路径压缩）
        function<int(int)> find = [&](int x) -> int {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);  // 路径压缩
            }
            return parent[x];
        };
        
        // 合并两个集合（按秩合并）
        auto unite = [&](int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                // 按秩合并
                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        };
        
        // 遍历矩阵，合并相连的城市
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    unite(i, j);
                }
            }
        }
        
        // 统计连通分量数量（根节点数量）
        int provinces = 0;
        for (int i = 0; i < n; i++) {
            if (parent[i] == i) {
                provinces++;
            }
        }
        
        return provinces;
    }
};

int main(int argc, char* argv[])
{
	auto fib = [](this auto&& self, int n, int i = 0, int num1 = 0, int num2 = 1)->int {
		return i >= n ? num1 : self(n, i + 1, num2, num1 + num2);
	};
	std::cout << fib(5);
	return 0;
}

```


![[1000346. 省份数量.cpp]]


END
<!--ID: 1769078758539-->


