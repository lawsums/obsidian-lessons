---
Date: 2026-01-11
Link: https://leetcode.com/problems/maximal-rectangle/
Category: 
- 栈
- 数组
- 动态规划
- 矩阵
- 单调栈
Difficulty: Hard
Completed: false
---

#栈 #数组 #动态规划 #矩阵 #单调栈 
<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5C%E8%AE%BA%E6%96%87%5CLeetcode%5C85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 85. 最大矩形

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

**示例 1：**

![](images/85_1722912576-boIxpm-image.png)

**输入：**matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
**输出：**6
**解释：**最大矩形如上图所示。

**示例 2：**

**输入：**matrix = [["0"]]
**输出：**0

**示例 3：**

**输入：**matrix = [["1"]]
**输出：**1

**提示：**

- `rows == matrix.length`
- `cols == matrix[0].length`
- `1 <= rows, cols <= 200`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

## Notes


## Solution 
```cpp
#include <stack>
#include <vector>
#include <algorithm>  // 用于 max 函数（部分编译器需显式包含）
using namespace std;  // LeetCode 提交时默认包含，此处为完整性添加

class Solution {
private:
    int n, m;                  // n：矩阵行数，m：矩阵列数
    vector<vector<int>> grid;  // 存储字符矩阵转换后的整数矩阵（'0'→0，'1'→1）

    /**
     * @brief 字符矩阵转整数矩阵
     * @param matrix 输入的二维字符矩阵（仅含 '0' 和 '1'）
     * 作用：将字符形式的 0/1 转为整数，方便后续柱高计算
     */
    void build(vector<vector<char>>& matrix) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 字符转整数：'0'的ASCII码 - '0' = 0，'1'的ASCII码 - '0' = 1
                grid[i][j] = matrix[i][j] - '0';
            }
        }
    }

public:
    /**
     * @brief 主函数：求二维二进制矩阵中只含 '1' 的最大矩形面积
     * @param matrix 输入的二维字符矩阵
     * @return 最大矩形的面积
     * 核心思路：将二维矩阵每行转为直方图，求所有直方图的最大面积（二维转一维降维求解）
     */
    int maximalRectangle(vector<vector<char>>& matrix) {
        // 边界处理：若矩阵为空，直接返回 0（避免 matrix[0] 越界）
        if (matrix.empty() || matrix[0].empty()) return 0;
        
        this->n = matrix.size();        // 初始化行数
        this->m = matrix[0].size();     // 初始化列数
        grid.assign(n, vector<int>(m, 0));  // 初始化整数矩阵（n行m列，初始值0）
        build(matrix);                  // 调用build转换字符矩阵

        int max_area = 0;               // 存储全局最大矩形面积
        vector<int> current_height(m, 0);  // 存储当前行对应的直方图柱高数组

        // 遍历每一行，构建该行对应的直方图
        for (int i = 0; i < n; i++) {
            // 遍历每一列，更新当前列的柱高
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1) {
                    // 当前位置是1，柱高 = 上一行柱高 + 1（连续1的高度叠加）
                    current_height[j]++;
                } else {
                    // 当前位置是0，柱高重置为0（无法形成连续1，直方图断开）
                    current_height[j] = 0;
                }
            }
            // 计算当前直方图的最大面积，更新全局最大值
            max_area = max(max_area, f1(current_height));
        }

        return max_area;
    }

    /**
     * @brief 辅助函数：求一维直方图的最大矩形面积（单调栈经典解法）
     * @param heights 直方图的柱高数组（输入为current_height）
     * @return 该直方图的最大矩形面积
     * 核心原理：对每个柱体，找到左右两侧第一个更矮的柱体，计算以该柱体为高的最大矩形面积
     */
    int f1(vector<int>& heights) {
        int n = heights.size();  // n = 柱体个数（即矩阵列数m）
        vector<int> left(n, -1);  // left[i]：i左侧第一个比heights[i]小的柱体索引（默认-1，代表无）
        vector<int> right(n, n);  // right[i]：i右侧第一个比heights[i]小的柱体索引（默认n，代表无）
        stack<int> mono_stack;    // 单调栈：存储柱体索引，确保索引对应的柱高严格递增

        // 第一遍遍历：求每个柱体的left[i]（左侧第一个更矮柱体）和right[i]（右侧第一个更矮柱体）
        for (int i = 0; i < n; ++i) {
            // 栈非空，且当前柱高 < 栈顶索引的柱高：栈顶元素的右侧第一个更矮柱体就是i
            while (!mono_stack.empty() && heights[mono_stack.top()] >= heights[i]) {
                right[mono_stack.top()] = i;  // 记录栈顶元素的right[i]
                mono_stack.pop();             // 栈顶元素已找到right，弹出（后续无需再处理）
            }
            // 此时栈顶是i左侧第一个更矮柱体（栈空则为-1）
            left[i] = mono_stack.empty() ? -1 : mono_stack.top();
            mono_stack.push(i);  // 当前索引入栈，维护栈的递增性质
        }

        int max_rect = 0;  // 存储当前直方图的最大矩形面积
        // 第二遍遍历：计算每个柱体对应的最大矩形面积
        for (int i = 0; i < n; ++i) {
            // 宽度 = 右侧第一个更矮柱体索引 - 左侧第一个更矮柱体索引 - 1
            int width = right[i] - left[i] - 1;
            // 面积 = 柱高 * 宽度（以当前柱体为高的最大矩形）
            int area = heights[i] * width;
            max_rect = max(max_rect, area);  // 更新最大值
        }

        return max_rect;
    }
};

```


![[85. 最大矩形.cpp]]


END
<!--ID: 1768203109012-->


