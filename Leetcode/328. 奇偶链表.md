---
Date: 2026-02-12
Link: https://leetcode.com/problems/odd-even-linked-list/
Category: 
- 链表
Difficulty: Medium
SimilarQuestions:  
- 分隔链表
- 将数组按照奇偶性转化
Completed: false
---

#链表 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.cpp
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 328. 奇偶链表

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

**示例 1:**

![](images/328_oddeven-linked-list.jpg)

**输入:** head = [1,2,3,4,5]
**输出:** [1,3,5,2,4]

**示例 2:**

![](images/328_oddeven2-linked-list.jpg)

**输入:** head = [2,1,3,5,6,4,7]
**输出:** [2,3,6,7,1,5,4]

**提示:**

- `n ==`  链表中的节点数
- `0 <= n <= 104`
- `-106 <= Node.val <= 106`

## Notes
这题主要就一个重点
Q: 会不会由于之前的节点前后联系影响安排?
A: 前面的都不会, 因为 next 都被修改了, 但是最后一个节点会

## Solution 

![[328. 奇偶链表.cpp]]

```cpp  
#include <bits/stdc++.h>
using namespace std;


// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        // 记录奇数和偶数节点        
        vector<vector<ListNode*>> even_odd(2, vector<ListNode*>{}); // 申请两个vec

        auto cur = head;
        size_t id = 0;
        while (cur) {
            // printf("cur->val = %d\n", cur->val);
            even_odd[id].push_back(cur);
            id = 1 - id; // 切换奇偶性
            cur = cur->next; // 下一个节点
        }

        // 先加入偶数节点, 然后奇数节点
        // Q: 会不会由于之前的节点前后联系影响安排?
        // A: 前面的都不会, 因为next都被修改了, 但是最后一个节点会
        ListNode* dummy = new ListNode(0);
        cur = dummy;
        for (int i = 0; i < 2; i++) {
            for (auto &node : even_odd[i]) {
                cur->next = node;
                cur = cur->next;
            } 
        }
        cur->next = nullptr; // 将最后一个节点的next置为nullptr

        return dummy->next;
    }
};

```  
END 
