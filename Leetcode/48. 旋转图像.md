---
Date: 2026-02-06
Link: https://leetcode.com/problems/rotate-image/
Category: 
- 数组
- 数学
- 矩阵
Difficulty: Medium
SimilarQuestions:  
- 判断矩阵经轮转后是否一致
Completed: false
---

#数组 #数学 #矩阵 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F.cpp
```
```button
name <font color="#548dd4">显示当前目录</font>
type link
action obsidian://shell-commands/?vault=Cpp&execute=qb5gwdzar5
```

```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 48. 旋转图像

给定一个 _n_ × _n_ 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**

![](images/48_mat1.jpg)

**输入：**matrix = [[1,2,3],[4,5,6],[7,8,9]]
**输出：**[[7,4,1],[8,5,2],[9,6,3]]

**示例 2：**

![](images/48_mat2.jpg)

**输入：**matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
**输出：**[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

**提示：**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

## Notes
### 核心统一框架（所有语言通用）
无论哪种语言，步骤、循环条件、索引操作**完全一致**，唯一区别是**两个元素的交换方式**：
1. 第一步：主对角线转置 → 循环`i从0到n-1`，`j从i+1到n-1`，交换`(i,j)`和`(j,i)`；
2. 第二步：每行水平翻转 → 循环`i从0到n-1`，`j从0到n/2-1`，交换`(i,j)`和`(i, n-1-j)`；
3. 所有语言均为**原地操作**，空间O(1)，时间O(n²)。

---

## 一、C++ 实现：直接用`swap`，最贴合Go框架
C++有**全局`std::swap`函数**（支持任意基本类型），矩阵用`vector<vector<int>>`表示，交换时直接`swap(matrix[i][j], matrix[j][i])`，**循环逻辑和Go完全一样**，几乎是逐行翻译。

### LeetCode48 C++ 代码（可直接提交）
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 第一步：主对角线转置（和Go完全一致，j从i+1开始）
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                swap(matrix[i][j], matrix[j][i]); // 直接用std::swap，替代Go的多赋值
            }
        }
        // 第二步：每行水平翻转（循环条件和Go完全一致）
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n / 2; ++j) {
                swap(matrix[i][j], matrix[i][n - 1 - j]); // 同样用swap
            }
        }
    }
};
```
### 关键说明
1. C++的`swap`会直接修改原变量（引用传递），无需手动处理指针/地址；
2. 矩阵参数用`vector<vector<int>>&`（引用），保证**原地操作**（和Go的切片特性一致，避免拷贝）；
3. 写逆时针90度/180度时，只改循环边界，`swap`语句完全复用。

---

## 二、Python 实现：和Go几乎完全一致
Python支持**原生多重赋值**（`a, b = b, a`），和Go的交换语法一模一样，矩阵用**二维列表**表示，循环逻辑、索引操作完全照搬Go，**是跨语言中最省心的**。

### LeetCode48 Python 代码（可直接提交）
```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        # 第一步：主对角线转置（和Go逐行一致）
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # 多赋值和Go完全一样
        # 第二步：每行水平翻转（循环条件一致）
        for i in range(n):
            for j in range(n // 2): # Python整数除法用//，和Go的/一致（Go中n是int，n/2自动取整）
                matrix[i][j], matrix[i][n - 1 - j] = matrix[i][n - 1 - j], matrix[i][j]
```
### 关键说明
1. Python的`range(n//2)`等价于Go的`j < n/2`（Go中int类型相除自动向下取整）；
2. Python的二维列表是**可变对象**，直接修改索引值就是原地操作，无需额外处理；
3. 交换语法和Go完全相同，写其他旋转角度时，直接复制Go的循环边界即可。

---

## 三、Java 实现：手动写交换（无原生多赋值/全局swap）
Java的限制：**无原生多重赋值**、**无全局通用的swap函数**（只有`Collections.swap`针对集合，不适合数组）、数组是**定长引用类型**——但核心框架仍完全复用，只需把交换逻辑改成「临时变量法」，这是Java的标准交换方式。

### 核心替换：Java的元素交换模板
把Go/Python的`a, b = b, a`和C++的`swap(a,b)`，替换为Java的**临时变量三行式**（所有场景通用）：
```java
// Java 交换任意两个int变量的标准写法（原地修改）
int temp = 矩阵[i][j];
矩阵[i][j] = 矩阵[目标行][目标列];
矩阵[目标行][目标列] = temp;
```
### LeetCode48 Java 代码（可直接提交）
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 第一步：主对角线转置（循环逻辑和Go完全一致）
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // 手动交换，替代多赋值/swap
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // 第二步：每行水平翻转（循环条件完全一致）
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                // 同样手动交换
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }
}
```
### 关键说明
1. Java的矩阵是`int[][]`（二维数组），`matrix.length`获取行数（正方形矩阵行列数一致）；
2. 所有循环边界、索引操作和Go**完全相同**，只是多了一个临时变量`temp`；
3. 原地操作：Java的二维数组参数是**引用传递**，直接修改数组元素会改变原对象，符合题目要求。

---

## 四、拓展：逆时针90度/180度 跨语言复用示例
以**180度旋转（垂直翻转+水平翻转）** 为例，展示跨语言的**框架复用性**——**仅改第一步循环逻辑，交换语法不变**，其他角度同理。
### 核心共性
1. C++：仍用`swap`，仅改循环边界；
2. Python：仍用`a,b = b,a`，仅改循环边界；
3. Java：仍用「临时变量法」，仅改循环边界。

### 180度旋转 Java 示例（仅改第一步，第二步复用）
```java
public void rotate180(int[][] matrix) {
    int n = matrix.length;
    // 第一步：垂直翻转（替代原主对角线转置，循环边界变，交换语法不变）
    for (int i = 0; i < n / 2; i++) {
        for (int j = 0; j < n; j++) {
            // 还是熟悉的临时变量交换
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n-1-i][j];
            matrix[n-1-i][j] = temp;
        }
    }
    // 第二步：水平翻转（和顺时针90度完全复用，一行没改）
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n-1-j];
            matrix[i][n-1-j] = temp;
        }
    }
}
```
C++/Python的180度实现，只需把上述Java的交换逻辑，替换为各自的交换语法，**循环边界完全一致**。

---

## 五、跨语言核心总结（精华速记，写题直接套）
| 语言 | 矩阵表示 | 元素交换方式（核心替换） | 循环逻辑/边界 |
|------|----------|--------------------------|---------------|
| Go   | [][]int  | `a, b = b, a`（多重赋值） | 基准框架      |
| C++  | vector<vector<int>>& | `swap(a, b)`（全局函数） | 和Go完全一致  |
| Python | List[List[int]] | `a, b = b, a`（和Go一致） | 和Go一致（n//2取整） |
| Java | int[][]  | 临时变量法（temp=a;a=b;b=temp） | 和Go完全一致  |

### 写题终极技巧
1. 先在**Go/Python**中理清**循环边界和翻转组合**（交换语法简洁，易调试）；
2. 再按上表**替换交换语法**，直接翻译成C++/Java，**循环逻辑一行不改**；
3. 所有矩阵旋转题（顺时针/逆时针/180度）均遵循此规则，实现**一套框架走天下**。

这种方法能最大程度减少跨语言写题的思维切换成本，把精力集中在**算法逻辑**（翻转组合、循环边界）上，而不是语言的语法细节，特别适合刷算法题的高效复用！

## Solution 

![[48. 旋转图像.cpp]]

```cpp  
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 第一步：主对角线转置（和Go完全一致，j从i+1开始）
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                swap(matrix[i][j], matrix[j][i]); // 直接用std::swap，替代Go的多赋值
            }
        }
        // 第二步：每行水平翻转（循环条件和Go完全一致）
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n / 2; ++j) {
                swap(matrix[i][j], matrix[i][n - 1 - j]); // 同样用swap
            }
        }
    }
};
```  
END 
