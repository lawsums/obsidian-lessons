---
Date: 2026-02-13
Link: https://leetcode.com/problems/rotate-array/
Category: 
- 数组
- 数学
- 双指针
Difficulty: Medium
SimilarQuestions:  
- 旋转链表
- 反转字符串中的单词 II
- 使子数组元素和相等
- 右移后的最大匹配索引数
Completed: false
---

#数组 #数学 #双指针 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C189.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84.cpp
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 189. 轮转数组

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

**输入:** nums = [1,2,3,4,5,6,7], k = 3
**输出:** `[5,6,7,1,2,3,4]`
**解释:**
向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：**nums = [-1,-100,3,99], k = 2
**输出：**[3,99,-1,-100]
**解释:** 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`


## Notes
**进阶：**
- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
1. 转链表可以降低复杂度
2. 通过 Copy_backward 模拟
3. Vector 操作
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？


## Solution 
**记得复制题目**

![[189. 轮转数组.cpp]]

```cpp  
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void rotate(vector<int> &nums, int k) {
        f4(nums, k);
    }

    // copy_forward整体移动 O(n), O(n)
    void f1(vector<int> &nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return;// 边界条件：空数组或k=0时直接返回
        k = k % n;                   // 处理k大于数组长度的情况
        int offset = n - k;

        // 保存最后k个需要旋转到前面的元素
        vector<int> need(nums.begin() + offset, nums.end());

        // 修复：使用正确的迭代器调用copy_backward，将前n-k个元素向后移动k位
        // 源区间：[nums.begin(), nums.end()-k)，目标结束位置：nums.end()
        std::copy_backward(nums.begin(), nums.end() - k, nums.end());

        // 将保存的最后k个元素放到数组前k个位置
        for (int i = 0; i < k; i++) {
            nums[i] = need[i];
        }
    }

    // insert O(n^2), O(1)
    void f2(vector<int> &nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return;// 边界条件：空数组或k=0时直接返回
        k = k % n;                   // 处理k大于数组长度的情况

        while (k--) {
            nums.insert(nums.begin(), nums.back());
            nums.pop_back();
        }
    }

    // list O(n), O(n)
    void f3(vector<int> &nums, int k) {
        // 将 vector 转换为 list（模拟链表操作）
        std::list<int> lst(nums.begin(), nums.end());
        int n = lst.size();
        if (n == 0 || k == 0) return;

        // 关键：k 取模，减少无效轮转
        k = k % n;

        // 向右轮转 k 步 = 把最后 k 个元素依次移到头部
        for (int i = 0; i < k; ++i) {
            // 取出最后一个元素
            int last = lst.back();
            // 删除最后一个元素
            lst.pop_back();
            // 将该元素插入到头部
            lst.push_front(last);
        }

        // 将 list 转回原 vector（完成结果覆盖）
        nums.assign(lst.begin(), lst.end());
    }

    // 反转三次 O(n), O(1)
    void f4(vector<int> &nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return;
        k = k % n;

        // 步骤1：反转整个数组
        std::reverse(nums.begin(), nums.end());
        // 步骤2：反转前 k 个元素
        std::reverse(nums.begin(), nums.begin() + k);
        // 步骤3：反转剩余 n-k 个元素
        std::reverse(nums.begin() + k, nums.end());
    }
};
```  
END 
