---
Date: 2026-01-14
Link: https://leetcode.com/problems/find-peak-element/
Category: 
- 数组
- 二分查找
Difficulty: Medium
SimilarQuestions:  
- 山脉数组的峰顶索引
- 寻找峰值 II
- 通过倒水操作让所有的水桶所含水量相等
- 统计数组中峰和谷的数量
- 找出峰值
Completed: false
---

#数组 #二分查找 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5C%E8%AE%A1%E7%BD%91%5CLeetcode%5C162.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 162. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

**示例 1：**

**输入：**nums = `[1,2,3,1]`
**输出：**2
**解释：**3 是峰值元素，你的函数应该返回其索引 2。

**示例 2：**

**输入：**nums = `[`1,2,1,3,5,6,4]
**输出：**1 或 5 
**解释：**你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

**提示：**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## Notes
这题的重点在于需要注意边界条件
1. mid == 0时 nums\[mid -  1]会越界
2. mid == n - 1时 nums\[mid +  1]会越界
所以在判定峰值的时候需要一个mid > 0 和 mid < n - 1的前置条件
同时==写法也很重要==, 使用一个peak判定是否为峰值, 我之前的传统写法如果加上mid > 0 和 mid < n - 1会过于臃肿

## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况：只有一个元素
        if (n == 1) return 0;
        
        // 二分查找（左闭右闭区间）
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            // 检查是否为峰值（需要避免越界）
            bool isPeak = true;
            if (mid > 0 && nums[mid] <= nums[mid - 1]) {
                isPeak = false; // 左侧更大，不是峰值
            }
            if (mid < n - 1 && nums[mid] <= nums[mid + 1]) {
                isPeak = false; // 右侧更大，不是峰值
            }
            if (isPeak) {
                return mid; // 找到峰值
            }
            
            // 不是峰值，向更大的一侧移动
            if (mid < n - 1 && nums[mid] < nums[mid + 1]) {
                // 右侧更大，峰值在右侧
                left = mid + 1;
            } else {
                // 左侧更大或两侧都小，峰值在左侧
                right = mid - 1;
            }
        }
        
        return -1; // 理论上不会走到这里（题目保证存在峰值）
    }
};

```


![[162. 寻找峰值.cpp]]


END
<!--ID: 1768379909685-->


