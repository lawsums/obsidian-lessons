---
Date: 2025-12-29
Link: https://leetcode.com/problems/pyramid-transition-matrix/
Category: 
Difficulty: Medium
Completed: false
---


<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C757.%20%E9%87%91%E5%AD%97%E5%A1%94%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5Cn%23%23%20Notes)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 757. 金字塔转换矩阵

你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 **少一个块** ，并且居中。

为了使金字塔美观，只有特定的 **三角形图案** 是允许的。一个三角形的图案由 **两个块** 和叠在上面的 **单个块** 组成。模式是以三个字母字符串的列表形式 `allowed` 给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。

- 例如，`"ABC"` 表示一个三角形图案，其中一个 `“C”` 块堆叠在一个 `'A'` 块(左)和一个 `'B'` 块(右)之上。请注意，这与 `"BAC"` 不同，`"B"` 在左下角，`"A"` 在右下角。

你从作为单个字符串给出的底部的一排积木 `bottom` 开始，**必须** 将其作为金字塔的底部。

在给定 `bottom` 和 `allowed` 的情况下，如果你能一直构建到金字塔顶部，使金字塔中的 **每个三角形图案** 都是在 `allowed` 中的，则返回 `true` ，否则返回 `false` 。

**示例 1：**

![](images/757_pyramid1-grid.jpg)

**输入：**bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
**输出：**true
**解释：**允许的三角形图案显示在右边。
从最底层(第 3 层)开始，我们可以在第 2 层构建“CE”，然后在第 1 层构建“E”。
金字塔中有三种三角形图案，分别是 “BCC”、“CDE” 和 “CEA”。都是允许的。

**示例 2：**

![](images/757_pyramid2-grid.jpg)

**输入：**bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]
**输出：**false
**解释：**允许的三角形图案显示在右边。
从最底层(即第 4 层)开始，创造第 3 层有多种方法，但如果尝试所有可能性，你便会在创造第 1 层前陷入困境。

**提示：**

- `2 <= bottom.length <= 6`
- `0 <= allowed.length <= 216`
- `allowed[i].length == 3`
- 所有输入字符串中的字母来自集合 `{'A', 'B', 'C', 'D', 'E', 'F'}`。
-  `allowed` 中所有值都是 **唯一的**

## Notes

这道题主要重点在于不同于一般的回溯, 它是一格一格回溯的, 就是类似于**数独**的形式, row 和 col 都需要遍历回溯, 所以时间开销巨大, 我们需要**记忆化搜索**才能通过这道题目

## Solution 

```cpp
// 普通回溯搜索
class Solution {
private:
    int n;
    unordered_map<string, vector<char>> mp;
    vector<string> path;

public:
    bool pyramidTransition(string bottom, vector<string>& allowed) {
        n = bottom.size();
        path.assign(n, "");
        path[0] = bottom;
        for (int i = 1; i < n; i++) {
            path[i] = string(n - i, ' '); // 使用空格初始化
        }

        // 构建映射
        for (const auto& elem : allowed) {
            string key = elem.substr(0, 2);
            mp[key].push_back(elem[2]);
        }

        return dfs(1, 0);
    }

    bool dfs(int r, int c) {
        // 这是一种回溯+DFS，用于构建金字塔
        if (r == n) {
            return true; // 成功构建到顶部
        }
        
        // 如果已经处理到当前行的末尾，转到下一行
        if (c == n - r) {
            return dfs(r + 1, 0);
        }
        
        // 获取当前位置需要基于的两个块
        string key = string(1, path[r-1][c]) + string(1, path[r-1][c+1]);
        
        if (!mp.count(key)) {
            return false; // 没有可用的转换规则
        }
        
        // 尝试所有可能的转换
        for (char ch : mp[key]) {
            path[r][c] = ch; // 设置当前块
            
            // 如果当前行还没完成，继续处理下一个位置
            bool result = false;
            if (c + 1 < n - r) {
                result = dfs(r, c + 1);
            } else {
                // 当前行完成，转到下一行
                result = dfs(r + 1, 0);
            }
            
            if (result) return true;
            
            // 回溯 - 不需要显式清除，因为会被后续的赋值覆盖
        }
        
        return false;
    }
};


// 记忆化搜索
class Solution {
private:
    unordered_map<string, vector<char>> rules;
    unordered_map<string, bool> memo; // 记忆化缓存
    
public:
    bool pyramidTransition(string bottom, vector<string>& allowed) {
        // 构建转换规则
        for (const auto& rule : allowed) {
            string key = rule.substr(0, 2);
            rules[key].push_back(rule[2]);
        }
        
        return dfs(bottom);
    }
    
    bool dfs(string current) {
        // 如果当前层只有一个字符，到达顶部
        if (current.size() == 1) return true;
        
        // 检查记忆化缓存
        if (memo.count(current)) return memo[current];
        
        // 生成所有可能的下一层
        vector<string> nextLevels;
        generateAllNextLevels(current, 0, "", nextLevels);
        
        // 对每个可能的下一层进行DFS
        for (const string& next : nextLevels) {
            if (dfs(next)) {
                memo[current] = true; // 缓存结果
                return true;
            }
        }
        
        memo[current] = false; // 缓存结果
        return false;
    }
    
    void generateAllNextLevels(const string& current, int index, 
                              string currentNext, vector<string>& results) {
        // 基准情况：已经处理完所有相邻块
        if (index == current.size() - 1) {
            results.push_back(currentNext);
            return;
        }
        
        // 获取当前相邻的两个字符
        string key = string(1, current[index]) + current[index + 1];
        
        // 如果没有转换规则，直接返回
        if (!rules.count(key)) return;
        
        // 对每个可能的转换字符进行递归
        for (char ch : rules[key]) {
            generateAllNextLevels(current, index + 1, 
                                 currentNext + ch, results);
        }
    }
};

```



![[757. 金字塔转换矩阵.cpp]]

``` include cpp
757. 金字塔转换矩阵.cpp
```


END
<!--ID: 1766980727155-->


