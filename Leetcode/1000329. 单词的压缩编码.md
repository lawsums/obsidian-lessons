---
Date: 2026-01-31
Link: https://leetcode.com/problems/iSwD2y/
Category: 
- 字典树
- 数组
- 哈希表
- 字符串
Difficulty: Medium
SimilarQuestions:  
Completed: false
---

#字典树 #数组 #哈希表 #字符串 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C1000329.%20%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 1000329. 单词的压缩编码

单词数组 `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：

- `words.length == indices.length`
- 助记字符串 `s` 以 `'#'` 字符结尾
- 对于每个下标 `indices[i]` ，`s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'`）的 **子字符串** 恰好与 `words[i]` 相等

给定一个单词数组 `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。

**示例 1：**

**输入：**words = ["time", "me", "bell"]
**输出：**10
**解释：**一组有效编码为 s = `"time#bell#" 和 indices = [0, 2, 5`] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "**time**#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "ti**me**#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#**bell**#"

**示例 2：**

**输入：**words = ["t"]
**输出：**2
**解释：**一组有效编码为 s = "t#" 和 indices = [0] 。

**提示：**

- `1 <= words.length <= 2000`
- `1 <= words[i].length <= 7`
- `words[i]` 仅由小写字母组成

注意：本题与主站 820 题相同： [https://leetcode.cn/problems/short-encoding-of-words/](https://leetcode.cn/problems/short-encoding-of-words/)

## Notes
经典字典树题目, 重点来了
1. 别忘了使用 TrieNode 的时候如果是面试需要和面试官讲一下**析构函数**
2. TrieNode 的构造函数中需要将 pass/end **置为零**, 否则有初始化错误

## Solution 
![[1000329. 单词的压缩编码.cpp]]


```cpp  
#include <bits/stdc++.h>
using namespace std;

class Trie {
public:
    void insert(string word) {
        auto cur = root; 
        cur->pass++;
        for (const auto &c : word) {
            auto path = c - 'a';
            if (cur->children[path] == nullptr) { // 如果没有就创建这个路径
                cur->children[path] = new TrieNode();
            }
            cur = cur->children[path]; // 移动到下一层
            cur->pass++; // 途径++
        }
        cur->end++; // 结尾++
    }

    bool isNotPrefix(string word) {
        auto cur = root; 
        for (const auto &c : word) {
            auto path = c - 'a';
            if (cur->children[path] == nullptr) { // 如果没有这个路径直接返回false
                return false;
            }
            cur = cur->children[path]; // 移动到下一层
        }
        // 结尾到达结尾之后返回答案
        return cur->pass == cur->end;
    }

    class TrieNode {
    public:
        int pass;
        int end;
        vector<TrieNode*> children;

        TrieNode() {
            pass = 0; // 重点!!!!!
            end = 0;
            children.assign(26, nullptr); // 首先赋值成nullptr节省内存
        }
    };

    TrieNode *root;

    Trie() { // TODO 没有释放内存
        root = new TrieNode();
    }

};

class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        // 排序去重
        sort(words.begin(), words.end());
        auto it = unique(words.begin(), words.end());
        words.erase(it, words.end());

        Trie t;
        for (auto& word: words) {
            reverse(word.begin(), word.end()); // 反转word
            t.insert(word); // 插入word
        }

        // 反向检测所有word是否是另一个单词的前缀
        // 如果是另一个单词的前缀的话, 就不需要加入答案
        // 否则ans += word.size() + 1;
        int ans = 0;
        for (auto &word: words) {
            if (t.isNotPrefix(word)) {
                ans += word.size() + 1;
            } 
        }
        return ans;
    }
};

```  
END
<!--ID: 1769999093929-->
 
