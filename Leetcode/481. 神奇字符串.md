---
Date: 2025-12-27
Link: https://leetcode.com/problems/magical-string/
Category: 
Difficulty: Medium
Completed: false
---


<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5C481.%20%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5Cn%23%23%20Notes)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 481. 神奇字符串

神奇字符串 `s` 仅由 `'1'` 和 `'2'` 组成，并需要遵守下面的规则：

- 将连续相同字符组 `'1'` 和 `'2'` 长度的序列连接起来会生成字符串 `s` 本身。

`s` 的前几个元素是 `s = "1221121221221121122……"` 。如果将 `s` 中连续的若干 `1` 和 `2` 进行分组，可以得到 `"1 22 11 2 1 22 1 22 11 2 11 22 ......"` 。每组中 `1` 或者 `2` 的出现次数分别是 `"1 2 2 1 1 2 1 2 2 1 2 2 ......"` 。上面的出现次数正是 `s` 自身。

给你一个整数 `n` ，返回在神奇字符串 `s` 的前 `n` 个数字中 `1` 的数目。

**示例 1：**

**输入：**n = 6
**输出：**3
**解释：**神奇字符串 s 的前 6 个元素是 “`122112`”，它包含三个 1，因此返回 3 。 

**示例 2：**

**输入：**n = 1
**输出：**1

**提示：**

- `1 <= n <= 105`

## Solution 
### 0x3f 方法
```python
class Solution:
    def magicalString(self, n: int) -> int:
        s = [1, 2, 2]
        i = 2
        while len(s) < n:
            s += [s[-1] ^ 3] * s[i]  # 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换
            i += 1
        return s[:n].count(1)
```


### 高效方法
```cpp
class Solution {
public:
    int magicalString(int n) {
        if (n == 0) return 0;
        if (n <= 3) return 1;

        vector<int> s = {1, 2, 2}; // 用 int 代替 char，更方便
        int i = 2;                 // 指向下一个要读取的“频次”
        int ans = 1;               // 前3个中只有1个'1'
        int next = 1;              // 下一个要添加的数字（1或2）

        while (s.size() < n) {
            int count = s[i++];    // 要添加 count 个 next
            for (int j = 0; j < count && s.size() < n; ++j) {
                s.push_back(next);
                if (next == 1) ans++;
            }
            next = 3 - next;       // 1<->2 切换（因为 3-1=2, 3-2=1）
        }

        return ans;
    }
};
```

### 我的方法
```csharp
class Solution {
public:
    int magicalString(int n) {
        string s = "1";
        int ans = 1;
        bool one = true;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < s[i] - '0' - 1; j++) {
                s.push_back(one ? '1' : '2');
                if (one) ans++;
                if (s.size() >= n) return ans;
            }
            one = !one;
            s.push_back(one ? '1' : '2');
            if (one) ans++;
            if (s.size() >= n) return ans;
        }
            
        return ans;
    }
};
```


``` include cpp
481. 神奇字符串.cpp
```


## Notes

END
<!--ID: 1766980727159-->


