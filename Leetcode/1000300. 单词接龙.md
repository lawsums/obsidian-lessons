---
Date: 2026-01-21
Link: https://leetcode.com/problems/om3reC/
Category: 
- 广度优先搜索
- 哈希表
- 字符串
Difficulty: Hard
SimilarQuestions:  
Completed: false
---

#广度优先搜索 #哈希表 #字符串 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C1000300.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 1000300. 单词接龙

在字典（单词列表） `wordList` 中，从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列：

- 序列中第一个单词是 `beginWord` 。
- 序列中最后一个单词是 `endWord` 。
- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典 `wordList` 中的单词。

给定两个长度相同但内容不同的单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，找到从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目** 。如果不存在这样的转换序列，返回 0。

**示例 1：**

**输入：**beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
**输出：**5
**解释：**一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

**示例 2：**

**输入：**beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
**输出：**0
**解释：**endWord "cog" 不在字典中，所以无法进行转换。

**提示：**

- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`、`endWord` 和 `wordList[i]` 由小写英文字母组成
- `beginWord != endWord`
- `wordList` 中的所有字符串 **互不相同**

注意：本题与主站 127 题相同： [https://leetcode.cn/problems/word-ladder/](https://leetcode.cn/problems/word-ladder/)

## Notes
Dijkstra基本步骤:
1. 初始化 path、distance、visited 等数组
2. 建图 graph
3. 使用 priority_queue 去存储 edge（边权类型）
4. 执行 `while (!pq.empty()))` 逻辑
	   1. 判断是否访问过了，如果访问过了就跳过，否则就是当前节点 `u`
	   2. 循环访问 `u` 的邻居节点 `v`，如果 `v` 访问过了的话就跳过，否则判断**是否原距离 `distance[v]` 小于当前距离加上边权值 `distance[u] + w`**，如果小于的话就 **更新距离和路径**
5. 结束

## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;
using aii = array<int, 2>;

class Solution {
private:
    unordered_map<string, int> str_to_index; 

public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // 检查 endWord 是否在 wordList 中
        if (find(wordList.begin(), wordList.end(), endWord) == wordList.end()) {
            return 0;
        }
        
        // 将 beginWord 添加到 wordList 中以便建图
        wordList.push_back(beginWord);
        int n = wordList.size();
        
        vector<int> distance(n, INT_MAX);
        // vector<bool> visited(n, false);
        bool visited[n];
        memset(visited, 0, n * sizeof(bool)); // 分配位置，值，长度
        vector<vector<aii>> graph(n, vector<aii>{});
        
        build(graph, wordList);
        
        // 找到 beginWord 的索引（现在是 wordList 的最后一个元素）
        int startIdx = n - 1;
        distance[startIdx] = 1; // 注意：起点长度为1，不是0
        
        // Dijkstra 算法
        auto cmp = [](aii& a, aii& b) { return a[1] > b[1]; };
        priority_queue<aii, vector<aii>, decltype(cmp)> pq(cmp);
        pq.push({startIdx, 1});
        
        while (!pq.empty()) {
            int u = pq.top()[0]; 
            pq.pop();
            
            if (visited[u]) continue;
            visited[u] = true;
            
            // 如果找到目标单词，直接返回
            if (wordList[u] == endWord) {
                return distance[u];
            }
            
            for (const auto &edge : graph[u]) {
                auto [v, w] = edge;
                int newDist = distance[u] + 1; // 每条边权重是1，但要计算节点数
                
                if (!visited[v] && newDist < distance[v]) {
                    distance[v] = newDist;
                    pq.push({v, distance[v]});
                }
            }
        }
        
        // 找到 endWord 的索引
        int endIdx = -1;
        for (int i = 0; i < n - 1; i++) { // 注意：n-1 因为最后一个是 beginWord
            if (wordList[i] == endWord) {
                endIdx = i;
                break;
            }
        }
        
        return distance[endIdx] == INT_MAX ? 0 : distance[endIdx];
    }

    void build(vector<vector<aii>> &graph, vector<string> &wordList) {
        int n = wordList.size();
        
        // 构建字符串到索引的映射
        for (int i = 0; i < n; i++) {
            str_to_index[wordList[i]] = i;
        }

        // 建图
        for (int i = 0; i < n; i++) {
            const string& word = wordList[i];
            for (int j = 0; j < word.size(); j++) {
                string new_word = word;
                for (char c = 'a'; c <= 'z'; c++) {
                    if (c == word[j]) continue;
                    new_word[j] = c;
                    
                    // 如果新单词在字典中，并且不是自己
                    if (str_to_index.count(new_word) && new_word != word) {
                        graph[i].push_back({str_to_index[new_word], 1});
                    }
                }
            }
        }
    }
};

```


![[1000300. 单词接龙.cpp]]


END
<!--ID: 1769078758549-->


