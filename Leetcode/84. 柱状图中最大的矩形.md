---
Date: 2026-01-02
Link: https://leetcode.com/problems/largest-rectangle-in-histogram/
Category: 
Difficulty: Hard
Completed: false
---


<!-- 点击自动创建文件 + 打开 Neovim -->
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 84. 柱状图中最大的矩形

给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![](images/84_histogram.jpg)

**输入：**heights = [2,1,5,6,2,3]
**输出：**10
**解释：**最大的矩形为图中红色区域，面积为 10

**示例 2：**

![](images/84_histogram-1.jpg)

**输入：** heights = [2,4]
**输出：** 4

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

## Notes
经典老题, 我们对于每个位置寻找它左右比它**数值更小**的元素的**坐标**并记录下来, 重点在于使用**单调栈**来实现这个效果, 简单来说就是左边找一遍, 然后右边找一遍.
重点在于使用单调栈的细节

## Solution 

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        // 寻找每个数左右比它小的坐标       
        int n = heights.size();
        auto ll = vector<int>(n, -1);
        auto rl = vector<int>(n, n);
    
        vector<int> stk;
        for (int i = 0; i < n; i++) {
            while (!stk.empty() && /* 我们需要维持一个单调递增, 如果不单调递增的话, 那么就可以把所有栈中的元素'右最近更小'更新 */ heights[i] < heights[stk.back()]) {
                rl[stk.back()] = i; // 更新
                stk.pop_back(); // 弹出元素防止继续更新
            }
            stk.push_back(i);
        } // 如果没有更新那么就默认n

        stk.clear();
        for (int i = n - 1; i >= 0; i--) {
            while (!stk.empty() && /* 我们需要维持一个单调递增, 如果不单调递增的话, 那么就可以把所有栈中的元素'左最近更小'更新 */ heights[i] < heights[stk.back()]) {
                ll[stk.back()] = i; // 更新
                stk.pop_back(); // 弹出元素防止继续更新
            }
            stk.push_back(i);
        } // 如果没有更新那么就默认-1

        // display(rl);
        // display(ll);
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, heights[i] * (rl[i] - ll[i] - 1));
        }
        return ans;
    }

    void display(vector<int> &arr) {
        for (int i = 0; i < arr.size(); i++) {
            printf("%d, ", arr[i]);
        }
        cout << endl;
    }
};


```


![[84. 柱状图中最大的矩形.cpp]]


END
<!--ID: 1767333941970-->


