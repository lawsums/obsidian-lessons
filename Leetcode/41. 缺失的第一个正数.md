---
Date: 2026-02-13
Link: https://leetcode.com/problems/first-missing-positive/
Category: 
- 数组
- 哈希表
Difficulty: Hard
SimilarQuestions:  
- 丢失的数字
- 寻找重复数
- 找到所有数组中消失的数字
- 情侣牵手
- 无限集中的最小数字
- 从一个范围内选择最多整数 I
- 执行操作后的最大 MEX
- 从一个范围内选择最多整数 II
- 大于等于顺序前缀和的最小缺失整数
Completed: false
---

#数组 #哈希表 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C41.%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.cpp
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 41. 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

**输入：**nums = [1,2,0]
**输出：**3
**解释：**范围 [1,2] 中的数字都在数组中。

**示例 2：**

**输入：**nums = [3,4,-1,1]
**输出：**2
**解释：**1 在数组中，但 2 没有。

**示例 3：**

**输入：**nums = [7,8,9,11,12]
**输出：**1
**解释：**最小的正数 1 没有出现。

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`

## Notes


## Solution 
**记得复制题目**

![[41. 缺失的第一个正数.cpp]]

```cpp  
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        return f1(nums);
    }

    // 鸽巢原理 O(n), O(1)
    int f1(vector<int>& nums) {
        int n = nums.size();
        
        // 第一步：将 [1, n] 范围内的数归位到对应的索引位置
        for (int i = 0; i < n; ++i) {
            // 循环交换：直到当前位置的数不在 [1, n] 范围内，或已经归位
            // 注意：必须用 while 而非 if，因为交换过来的数可能也需要归位
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 交换 nums[i] 和 nums[nums[i]-1]，让 nums[i] 归位
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        
        // 第二步：遍历数组，找第一个“数≠索引+1”的位置
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        // 第三步：如果 [1, n] 都在，返回 n+1
        return n + 1;
    }

    // 哈希表 O(n), O(n)
    int f2(vector<int>& nums) {
        int max_ = *max_element(nums.begin(), nums.end());
        if (max_ <= 0) return 1;
        
        unordered_map<int, int> mp;
        for (auto num : nums) {
            mp[num]++;
        }
        
        for (int i = 1; i <= max_; i++) {
            if (!mp.count(i)) return i;
        }

        return max_ + 1;
    }
};

```  
END 
