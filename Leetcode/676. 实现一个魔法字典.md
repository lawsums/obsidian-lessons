---
Date: 2026-01-26
Link: https://leetcode.com/problems/implement-magic-dictionary/
Category: 
- 深度优先搜索
- 设计
- 字典树
- 哈希表
- 字符串
Difficulty: Medium
SimilarQuestions:  
- 实现 Trie (前缀树)
- 词典中最长的单词
Completed: false
---

#深度优先搜索 #设计 #字典树 #哈希表 #字符串 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C676.%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 676. 实现一个魔法字典

设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 **互不相同** 。 如果给出一个单词，请判定能否只将这个单词中**一个**字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。

实现 `MagicDictionary` 类：

- `MagicDictionary()` 初始化对象
- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同
- `bool search(String searchWord)` 给定一个字符串 `searchWord` ，判定能否只将字符串中 **一个** 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `true` ；否则，返回 `false` 。

**示例：**

**输入**
["MagicDictionary", "buildDict", "search", "search", "search", "search"]
[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
**输出**
[null, null, false, true, false, false]

**解释**
MagicDictionary magicDictionary = new MagicDictionary();
magicDictionary.buildDict(["hello", "leetcode"]);
magicDictionary.search("hello"); // 返回 False
magicDictionary.search("hhllo"); // 将第二个 'h' 替换为 'e' 可以匹配 "hello" ，所以返回 True
magicDictionary.search("hell"); // 返回 False
magicDictionary.search("leetcoded"); // 返回 False

**提示：**

- `1 <= dictionary.length <= 100`
- `1 <= dictionary[i].length <= 100`
- `dictionary[i]` 仅由小写英文字母组成
- `dictionary` 中的所有字符串 **互不相同**
- `1 <= searchWord.length <= 100`
- `searchWord` 仅由小写英文字母组成
- `buildDict` 仅在 `search` 之前调用一次
- 最多调用 `100` 次 `search`

## Notes


## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;


class TrieNode {
public:
    int pass;
    int end;
    vector<TrieNode*> nexts;

    TrieNode() {
        pass = 0;
        end = 0;
        nexts = vector<TrieNode*>(26, nullptr);
    }

    ~TrieNode() {
        for (auto& child : nexts) {
            delete child;
        }
    }
};

class MagicDictionary {
private:
    TrieNode *root;

public:
    /** Initialize your data structure here. */
    MagicDictionary() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        auto cur = root;
        cur->pass++;
        for (const auto& c : word) {
            auto path = c - 'a';
            // 如果不存在就创建
            if (cur->nexts[path] == nullptr) { 
                cur->nexts[path] = new TrieNode();
            }
            cur = cur->nexts[path];
            cur->pass++;
        }
        cur->end++;
    }

    void buildDict(vector<string> dictionary) {
        for (const auto &s : dictionary) {
            insert(s); // 插入所有的字符串
        }
    }
    
    bool search(string searchWord) {
        return handler(searchWord, root, true, 0);
    }

    bool handler(string &searchWord, TrieNode* cur, bool canReplace, int step) {
        if (step == searchWord.size()) return cur->end && !canReplace;

        auto path = searchWord[step] - 'a'; // 设置当前路径
        bool found = false;

        if (cur->nexts[path] != nullptr) {  // 如果当前路径存在
            found |= handler(searchWord, cur->nexts[path], canReplace, step + 1);
        } 

        if (!found && canReplace) { // 如果还没找到而且当前可以替换, 则尝试替换成其他25个字母
            for (int i = 0; i < 26; i++) {
                if (i == path || cur->nexts[i] == nullptr) continue;
                found |= handler(searchWord, cur->nexts[i], false, step + 1);
            }
        } 

        return found;
    }
};
```


![[676. 实现一个魔法字典.cpp]]


END
<!--ID: 1769485992056-->


