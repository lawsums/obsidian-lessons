---
Date: 2026-02-09
Link: https://leetcode.com/problems/balance-a-binary-search-tree/
Category: 
- 贪心
- 树
- 深度优先搜索
- 二叉搜索树
- 分治
- 二叉树
Difficulty: Medium
SimilarQuestions:  
Completed: false
---

#贪心 #树 #深度优先搜索 #二叉搜索树 #分治 #二叉树 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C1285.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1.cpp
```

`button-anki-open`   `button-anki-update`

## 1285. 将二叉搜索树变平衡

给你一棵二叉搜索树，请你返回一棵 **平衡后** 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。

如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 `1` ，我们就称这棵二叉搜索树是 **平衡的** 。

**示例 1：**

![](images/1285_balance1-tree.jpg)

**输入：**root = [1,null,2,null,3,null,4,null,null]
**输出：**[2,1,3,null,null,null,4]
**解释：**这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。

**示例 2：**

![](images/1285_balanced2-tree.jpg)

**输入:** root = [2,1,3]
**输出:** [2,1,3]

**提示：**

- 树节点的数目在 `[1, 104]` 范围内。
- `1 <= Node.val <= 105`

## Notes


## Solution 

![[1285. 将二叉搜索树变平衡.cpp]]
```cpp  
#include <algorithm>
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void inorder(TreeNode* node, vector<TreeNode*> &nodes) {
        if (!node) return;

        inorder(node->left, nodes);
        nodes.push_back(node);
        inorder(node->right, nodes);
    }

    TreeNode* build(int l, int r, vector<TreeNode*> &nodes) {
        if (l > r) return nullptr;

        int mid = l + (r - l) / 2;

        auto node = new TreeNode(nodes[mid]->val);
        node->left = build(l, mid - 1, nodes);
        node->right = build(mid + 1, r, nodes);

        return node;
    }

    TreeNode* balanceBST(TreeNode* root) {
        // 获取元素数组
        vector<TreeNode*> nodes;
        inorder(root, nodes);

        // 构建这棵树
        return build(0, nodes.size() - 1, nodes);
    }
};

```  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    // 核心方法：将非平衡BST转为平衡BST
    public TreeNode balanceBST(TreeNode root) {
        // 1. 中序遍历获取有序的节点值列表
        List<Integer> nodeVals = new ArrayList<>();
        inorder(root, nodeVals);
        
        // 2. 递归构建平衡BST
        return buildTree(0, nodeVals.size() - 1, nodeVals);
    }
    
    // 中序遍历：二叉搜索树的中序遍历结果是有序的
    private void inorder(TreeNode node, List<Integer> nodeVals) {
        if (node == null) {
            return;
        }
        inorder(node.left, nodeVals);
        nodeVals.add(node.val); // Java的List是引用传递，直接添加即可
        inorder(node.right, nodeVals);
    }
    
    // 分治法构建平衡BST：取中间元素为根，左右递归
    private TreeNode buildTree(int left, int right, List<Integer> nodeVals) {
        if (left > right) {
            return null;
        }
        // 取中间位置作为根节点，避免(left+right)/2的整数溢出
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nodeVals.get(mid));
        // 构建左子树
        root.left = buildTree(left, mid - 1, nodeVals);
        // 构建右子树
        root.right = buildTree(mid + 1, right, nodeVals);
        return root;
    }
}
```
