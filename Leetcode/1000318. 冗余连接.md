---
Date: 2026-01-24
Link: https://leetcode.com/problems/7LpjUW/
Category: 
- 深度优先搜索
- 广度优先搜索
- 并查集
- 图
Difficulty: Medium
SimilarQuestions:  
Completed: false
---

#深度优先搜索 #广度优先搜索 #并查集 #图 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C1000318.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 1000318. 冗余连接

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。

**示例 1：**

![](images/1000318_1626676174-hOEVUL-image.png)

**输入:** edges = [[1,2],[1,3],[2,3]]
**输出:** [2,3]

**示例 2：**

![](images/1000318_1626676179-kGxcmu-image.png)

**输入:** edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
**输出:** [1,4]

**提示:**

- `n == edges.length`
- `3 <= n <= 1000`
- `edges[i].length == 2`
- `1 <= ai < bi <= edges.length`
- `ai != bi`
- `edges` 中无重复元素
- 给定的图是连通的 

注意：本题与主站 684 题相同： [https://leetcode.cn/problems/redundant-connection/](https://leetcode.cn/problems/redundant-connection/)

## Notes
标准并查集题目
1. 建立并查集类, 实现`find`, `unite`两个函数
2. 直接使用即可



## Solution 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // 并查集核心：父节点数组
    vector<int> parent;
    // 查找（带路径压缩，优化查询效率）
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩：让x直接指向根节点
        }
        return parent[x];
    }
    // 合并（带按秩合并，优化合并效率）
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootY] = rootX; // 合并两个集合（rootY指向rootX）
        }
    }

public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        return f1(edges);
    }

    // 并查集做法
    vector<int> f1(vector<vector<int>>& edges) {
        int n = edges.size(); // 题目提示n == edges.length（节点数=边数，因为树+1条边）
        parent.resize(n + 1); // 节点值1~n，数组索引0不用
        
        // 初始化并查集：每个节点父节点是自己
        for (int i = 1; i <= n; ++i) {
            parent[i] = i;
        }
        
        // 遍历每条边，判断是否形成环
        for (auto& edge : edges) {
            int a = edge[0], b = edge[1];
            if (find(a) == find(b)) {
                // 两个节点已连通，当前边是冗余边（最后出现的，直接返回）
                return edge;
            }
            // 未连通，合并两个集合
            unite(a, b);
        }
        
        return {-1, -1}; // 题目保证有解，不会走到这里
    }


    // 我的方法, 错误在只考虑连通性没有考虑成环 
    vector<int> f2(vector<vector<int>>& edges) {
        int n = 0;
        for (auto &e : edges) {
            n = max(n, max(e[0], e[1])); // 更新当前最大节点编号
        }

        // 统计入度
        vector<int> indegree(n + 1, 0);
        for (const auto& edge : edges) {
            indegree[edge[0]]++;
            indegree[edge[1]]++;
        }
        
        // 倒着遍历边, 如果哪个边删除了不会导致入度降为0, 就直接return
        for (int i = edges.size() - 1; i >= 0; i--) {
            if (indegree[edges[i][0]] == 1 || indegree[edges[i][1]] == 1) continue; 
            return edges[i];
        }

        return {-1, -1}; // 不会到达这个地方
    }
};
```


![[1000318. 冗余连接.cpp]]


END
<!--ID: 1769485992070-->


