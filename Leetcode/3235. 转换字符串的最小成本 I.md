---
Date: 2026-01-29
Link: https://leetcode.com/problems/minimum-cost-to-convert-string-i/
Category: 
- 图
- 数组
- 字符串
- 最短路
Difficulty: Medium
SimilarQuestions:  
- K 次操作转变字符串
- 转换字符串的最少操作次数
Completed: false
---

#图 #数组 #字符串 #最短路 
```button
name <font color="#548dd4">打开nvim（自动创建.cpp）</font>
type link
action file:///E%3A%5CDocuments%5CObsidian_%5CCpp%5CLeetcode%5C3235.%20%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%20I.cpp
```
```button
name <font color="#6aa84f">刷新Solution代码</font>
type link
action obsidian://advanced-uri?command=templater%3Aexecute-script&script=%0A%20%20(async%20(tp)%20%3D%3E%20%7B%0A%20%20%20%20const%20fs%20%3D%20require('fs')%3B%0A%20%20%20%20const%20path%20%3D%20require('path')%3B%0A%20%20%20%20const%20targetFile%20%3D%20tp.config.target_file%3B%0A%20%20%20%20const%20cppFilePath%20%3D%20path.join(%0A%20%20%20%20%20%20targetFile.vault.adapter.basePath%2C%0A%20%20%20%20%20%20targetFile.parent.path%2C%0A%20%20%20%20%20%20%60%24%7BtargetFile.basename%7D.cpp%60%0A%20%20%20%20)%3B%0A%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%2F%2F%20%E8%AF%BB%E5%8F%96%E7%AC%94%E8%AE%B0%E5%86%85%E5%AE%B9%E5%92%8C%20cpp%20%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20noteContent%20%3D%20await%20tp.file.content()%3B%0A%20%20%20%20%20%20let%20cppContent%20%3D%20fs.readFileSync(cppFilePath%2C%20'utf-8').trim()%20%7C%7C%20%22%2F%2F%20%E6%9A%82%E6%97%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%22%3B%0A%0A%20%20%20%20%20%20%2F%2F%20%E6%9B%BF%E6%8D%A2%20Solution%20%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%0A%20%20%20%20%20%20const%20updatedContent%20%3D%20noteContent.replace(%0A%20%20%20%20%20%20%20%20%2F(%23%23%20Solution%5Cn%5Cn)(%5B%5Cs%5CS%5D*%3F)(%3F%3D%5CnEND)%2F%2C%0A%20%20%20%20%20%20%20%20(match%2C%20solutionTitle)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20%60%24%7BsolutionTitle%7D%60%60cpp%0A%24%7BcppContent%7D%0A%60%60%60%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20)%3B%0A%0A%0A%20%20%20%20%20%20await%20tp.file.modify(updatedContent)%3B%0A%20%20%20%20%20%20new%20Notice(%22%E2%9C%85%20Solution%20%E5%88%B7%E6%96%B0%E6%88%90%E5%8A%9F%EF%BC%81%22)%3B%0A%20%20%20%20%7D%20catch%20(error)%20%7B%0A%20%20%20%20%20%20console.error(%22%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%22%2C%20error)%3B%0A%20%20%20%20%20%20new%20Notice(%60%E2%9D%8C%20%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9A%24%7Berror.message%7D%60)%3B%0A%20%20%20%20%7D%0A%20%20%7D)(tp)%3B%20%2F%2F%20%E4%BC%A0%E9%80%92%20tp%20%E5%AF%B9%E8%B1%A1%E5%88%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%0A
```

`button-anki-open`   `button-anki-update`

DECK: 面试题-hot100

## 3235. 转换字符串的最小成本 I

给你两个下标从 **0** 开始的字符串 `source` 和 `target` ，它们的长度均为 `n` 并且由 **小写** 英文字母组成。

另给你两个下标从 **0** 开始的字符数组 `original` 和 `changed` ，以及一个整数数组 `cost` ，其中 `cost[i]` 代表将字符 `original[i]` 更改为字符 `changed[i]` 的成本。

你从字符串 `source` 开始。在一次操作中，**如果** 存在 **任意** 下标 `j` 满足 `cost[j] == z`  、`original[j] == x` 以及 `changed[j] == y` 。你就可以选择字符串中的一个字符 `x` 并以 `z` 的成本将其更改为字符 `y` 。

返回将字符串 `source` 转换为字符串 `target` 所需的 **最小** 成本。如果不可能完成转换，则返回 `-1` 。

**注意**，可能存在下标 `i` 、`j` 使得 `original[j] == original[i]` 且 `changed[j] == changed[i]` 。

**示例 1：**

**输入：**source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
**输出：**28
**解释：**将字符串 "abcd" 转换为字符串 "acbe" ：
- 更改下标 1 处的值 'b' 为 'c' ，成本为 5 。
- 更改下标 2 处的值 'c' 为 'e' ，成本为 1 。
- 更改下标 2 处的值 'e' 为 'b' ，成本为 2 。
- 更改下标 3 处的值 'd' 为 'e' ，成本为 20 。
产生的总成本是 5 + 1 + 2 + 20 = 28 。
可以证明这是可能的最小成本。

**示例 2：**

**输入：**source = "aaaa", target = "bbbb", original = ["a","c"], changed = ["c","b"], cost = [1,2]
**输出：**12
**解释：**要将字符 'a' 更改为 'b'：
- 将字符 'a' 更改为 'c'，成本为 1 
- 将字符 'c' 更改为 'b'，成本为 2 
产生的总成本是 1 + 2 = 3。
将所有 'a' 更改为 'b'，产生的总成本是 3 * 4 = 12 。

**示例 3：**

**输入：**source = "abcd", target = "abce", original = ["a"], changed = ["e"], cost = [10000]
**输出：**-1
**解释：**无法将 source 字符串转换为 target 字符串，因为下标 3 处的值无法从 'd' 更改为 'e' 。

**提示：**

- `1 <= source.length == target.length <= 105`
- `source`、`target` 均由小写英文字母组成
- `1 <= cost.length== original.length == changed.length <= 2000`
- `original[i]`、`changed[i]` 是小写英文字母
- `1 <= cost[i] <= 106`
- `original[i] != changed[i]`

## Notes
这题考察的是 **Floyd-Warshall** 算法
### 为什么Floyd-Warshall需要最外层循环k
你想知道Floyd-Warshall算法为什么必须把中转点 `k` 放在最外层，核心原因是：**这个算法的本质是「逐步解锁中转点」，通过外层的k循环，让算法能依次把每个节点作为合法中转点，层层叠加出所有可能的中转路径，最终求出全局最小路径**。

如果把k放在内层（比如你之前写的i-j-k），就失去了「逐步解锁中转」的逻辑，只能计算**单次中转**的路径，无法处理**多轮中转**（比如`i→k1→k2→j`），这也是你之前代码返回-1的根本原因。

下面用**通俗的比喻+分步拆解+反例验证**讲清楚，不用复杂公式，只看核心逻辑。

### 一、先搞懂Floyd-Warshall的核心思想
Floyd-Warshall是**多源最短路径算法**（一次性求所有节点之间的最短路径），对于任意两个节点`i`（起点）和`j`（终点），最短路径只有两种可能：
1. **直连路径**：`i`直接到`j`，没有任何中转点；
2. **中转路径**：`i`经过**1个或多个中转点**到`j`，比如`i→k→j`、`i→k1→k2→j`、`i→k1→k2→k3→j`等。

算法的目标就是：**对所有i和j，不断尝试用新的中转点优化路径，直到所有中转点都被尝试过，得到的就是最短路径**。

而`k`循环的作用，就是**按顺序把每个节点k变成「可以用的中转点」**，每次解锁一个k，就更新所有通过k的i→j路径。

### 二、外层k的本质：逐步解锁中转点，层层叠加路径
我们以**3个节点（k1、k2、k3）**为例，模拟外层k循环的执行过程，理解「逐步解锁」的逻辑：
假设节点集合是`{0,1,2}`，k循环从0到2依次执行，每一轮k都代表「**现在允许使用前k+1个节点作为中转点**」。

#### 第1轮：k=0（解锁中转点0）
此时算法只允许用**0作为中转点**，更新所有`i→0→j`的路径：
- 比如原本`i=1→j=2`的直连成本是10，而`1→0→2`的成本是3+4=7，就把`1→2`的路径更新为7；
- 这一轮后，所有i和j的路径，都是「直连」或「经过0中转」的最短路径。

#### 第2轮：k=1（解锁中转点1）
此时算法允许用**0和1作为中转点**，更新所有`i→1→j`的路径，**且能叠加之前的中转结果**：
- 比如原本`i=2→j=0`的路径是8，而`2→1→0`的成本是2+3=5，就更新为5；
- 更关键的是：能处理**两次中转**，比如`i=2→j=0`其实是`2→1→0`（用了1个中转），而如果有`i=2→j=3`，可能是`2→1→0→3`（用了0和1两个中转）——因为0已经在第一轮解锁，1在第二轮解锁，算法会自动叠加。

#### 第3轮：k=2（解锁中转点2）
此时算法允许用**0、1、2所有节点作为中转点**，更新所有`i→2→j`的路径，同时叠加前两轮的所有中转结果；
这一轮结束后，所有i和j的路径，已经尝试了**所有可能的中转点组合**，得到的就是全局最短路径。

简单说：**外层k循环，让算法从「无中转」→「1个中转」→「2个中转」→…→「所有节点中转」，逐步逼近最短路径**。

### 三、用「修路」的通俗比喻理解
把节点看作**城市**，节点间的边看作**直接公路**，路径成本看作**公路距离**，Floyd-Warshall就是**逐步修通中转城市的公路，让任意两个城市的通行距离最短**。
- k循环的每一轮，就是**修通第k个城市的所有连接线**，让这个城市成为所有其他城市之间的「合法中转站」；
- 先修通城市0，所有城市都可以走城市0中转；再修通城市1，所有城市既可以走0中转，也可以走1中转，还可以走0→1连转；最后修通所有城市，所有连转方式都被解锁，任意两个城市的最短距离就确定了。

如果把k放在内层，相当于**每次只允许临时用k中转一次，修通后又马上封闭**，无法实现「连转」，自然求不出多轮中转的最短路径。

### 四、反例验证：k放内层会发生什么？
回到你之前的代码，循环顺序是`i→j→k`（k在内层），我们用一个简单的3节点例子验证问题：
已知：`0→1=1`，`1→2=2`，`0→2=5`，求`0→2`的最短路径（正确结果是`0→1→2=3`）。

#### 当k放内层（i-j-k）时，执行过程：
1. 先固定i=0，j=2，再遍历k=0、1、2：
   - k=0/2：无意义（k=i或k=j），跳过；
   - k=1：计算`0→1 + 1→2 = 3`，此时会把`0→2`更新为3（这一步看似没问题）；
2. 但如果是**4节点多轮中转**（比如`0→1=1`，`1→2=2`，`2→3=3`，`0→3=10`），求`0→3`的最短路径（正确是`0→1→2→3=6`）：
   - 固定i=0，j=3，遍历k=0、1、2、3：
     - k=1：`0→1 +1→3`（1→3无路径，无效）；
     - k=2：`0→2 +2→3`（0→2无路径，无效）；
     - 最终无法更新`0→3`的路径，仍为10，**丢失了多轮中转的路径**。

原因很简单：k放内层时，**算法只能看到「直接通过k中转的一次路径」，无法看到「k1→k2连转的路径」**——因为k1和k2没有被「同时解锁」，算法不知道k1可以先中转到k2，再中转到j。

#### 当k放外层（k-i-j）时，执行过程：
还是4节点的例子，k依次遍历0、1、2、3：
1. k=1：解锁中转点1，更新`0→1→j`的路径，此时`0→1`有效，但`1→3`无效，无更新；
2. k=2：解锁中转点2，先更新`i→2→j`的路径，同时**叠加k=1的结果**：
   - 先更新`1→2→3=5`（1→2=2，2→3=3），让`1→3`的路径从无变为5；
   - 再更新`0→1→3=1+5=6`，让`0→3`的路径从10更新为6；
3. 最终得到正确的多轮中转路径。

### 五、一句话总结核心
**Floyd-Warshall的k循环在外层，是为了让每个中转点k被「永久解锁」，后续的循环可以基于已解锁的所有中转点（k=0~当前k）进行连转，从而覆盖「1次中转、2次中转、…、n次中转」的所有可能情况**。

如果k在内层，中转点只是「临时借用」，无法叠加连转，算法就退化成了「只能求单次中转的最短路径」，完全失去了Floyd-Warshall的核心能力。

### 补充：和Dijkstra的小区别（帮你巩固）
你最初想过用Dijkstra（单源最短路径），其实对26个字母的场景，Dijkstra（对每个节点跑一次）也能解，而Floyd-Warshall更简洁（代码量少）。
- Dijkstra是「对每个起点i，求i到所有j的最短路径」，需要循环26次；
- Floyd-Warshall是「一次性求所有i到所有j的最短路径」，靠k-i-j三层循环实现；
两者的核心都是**利用中转点优化路径**，只是实现方式不同，而Floyd-Warshall的k外层循环，就是它实现「多源多中转」的关键。

### 最终关键点回顾
1. Floyd-Warshall的k是**中转点**，外层k的本质是**逐步永久解锁中转点**，让算法能叠加连转路径；
2. 解锁顺序是k=0→n-1，每轮解锁后，所有i-j的路径都能基于「已解锁的所有中转点」优化；
3. k放内层会导致中转点「临时借用」，无法连转，只能处理单次中转，丢失多轮中转的最短路径；
4. 26个字母的场景（节点数极少），Floyd-Warshall的三层循环（26\*26\*26=17576次）效率极高，完全无压力。
---

### 你的3个关键错误（按严重性排序）
#### 错误1：Floyd-Warshall的循环顺序完全错了（最核心）
你把**中转点k放在了最内层**，正确的顺序必须是**k（中转点）→ i（起点）→ j（终点）**。
- 错误逻辑：`i-j-k` 相当于固定起点和终点，再找中转，无法实现**多轮中转**（比如i→k1→k2→j）；
- 正确逻辑：`k-i-j` 先固定一个中转点k，更新所有通过k的i→j路径，再换另一个中转点，逐步叠加所有可能的中转方式，才能求出全局最小路径。

这是导致测试用例中很多字母无法找到中转路径、误判为`INT_MAX`的根本原因。

#### 错误2：建图时没有去重，直接覆盖相同边的成本
测试用例中可能存在**同一个原字符→目标字符的多条直接边**（比如a→d有成本2和成本5），你的代码会直接用最后一个cost覆盖，而正确的做法是**保留最小的直接成本**。
比如代码中加了`graph[x][y] = min((long long)c, graph[x][y]);`，就是为了处理这种情况。

#### 错误3：使用`INT_MAX`导致溢出+类型不匹配
1. `INT_MAX`是int类型（约2e9），两个`INT_MAX`相加会直接**int溢出**，变成负数，导致路径更新逻辑完全错误；
2. 最终结果是`long long`，用`int`的邻接矩阵会有类型转换隐患；
3. 修复方式：改用`long long`的邻接矩阵，初始化值为`LLONG_MAX`（long long的最大值），且更新路径前先判断`i→k`和`k→j`是否可达（避免`LLONG_MAX`相加）。

### 额外优化点（你代码中忽略的）
- 自己到自己的路径无需`continue`：Floyd-Warshall会自动处理`graph[i][i] = 0`，不影响计算；
- 溢出防护：**必须先判断路径可达，再计算相加**，否则`LLONG_MAX + 任意数`会溢出成负数，导致`min`判断错误。

### 测试用例验证
对于你给出的测试用例：
`source = "abadcdadac"，target = "baddbccdac"`
修复后的代码会正确计算出每个字符的最小转换成本，累加后得到**预期结果57**，而非-1。

### 总结
本次解题的3个核心修复点：
1. Floyd-Warshall循环顺序改为**中转点k在外层**（k→i→j）；
2. 建图时对**相同原→目字符的边去重**，保留最小直接成本；
3. 邻接矩阵改用`long long`类型，初始化`LLONG_MAX`，并增加**可达性判断**避免溢出。

这三个错误都是Floyd-Warshall算法的经典坑，记住这几点，这类**有限节点（26个字母）的多源最短路径问题**就能完美解决。

## Solution 

![[3235. 转换字符串的最小成本 I.cpp]]


```cpp  
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {
        // 初始化26个字母的邻接矩阵，用LLONG_MAX避免int溢出，且适配long long计算
        vector<vector<long long>> graph(26, vector<long long>(26, LLONG_MAX));
        // 自己到自己的成本为0
        for (int i = 0; i < 26; i++) {
            graph[i][i] = 0;
        }

        // 建图：注意**去重**——同一个original->changed可能有多个cost，保留最小的
        int n = original.size();
        for (int i = 0; i < n; i++) {
            int x = original[i] - 'a';
            int y = changed[i] - 'a';
            int c = cost[i];
            graph[x][y] = min((long long)c, graph[x][y]); // 关键：保留最小直接成本
        }

        // Floyd-Warshall核心：k是中转点，必须放在最外层！
        for (int k = 0; k < 26; k++) { // 中转点k：i -> k -> j
            for (int i = 0; i < 26; i++) { // 起点i
                for (int j = 0; j < 26; j++) { // 终点j
                    // 关键：判断i->k和k->j是否可达（避免LLONG_MAX相加溢出）
                    if (graph[i][k] != LLONG_MAX && graph[k][j] != LLONG_MAX) {
                        graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
                    }
                }
            }
        }

        // 计算总转换成本
        long long ans = 0;
        int m = source.size();
        for (int i = 0; i < m; i++) {
            int x = source[i] - 'a';
            int y = target[i] - 'a';
            if (graph[x][y] == LLONG_MAX) { // 无法转换，返回-1
                return -1;
            }
            ans += graph[x][y];
        }
        return ans;
    }
};
```  
END
<!--ID: 1769999093926-->
 
