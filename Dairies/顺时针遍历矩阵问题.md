你要解决的是**二维矩阵顺时针螺旋遍历**问题，对于示例 `[[1,2,3],[4,5,6],[7,8,9]]` 输出 `123698745`，**最优解法是「边界收缩法」**（也叫方向模拟法）。

这个方法的核心思路是：**用四个变量标记矩阵的上下左右边界，按「右→下→左→上」的顺时针方向遍历，每遍历完一个方向就收缩对应边界，直到边界交叉（遍历完成）**。
### 为什么这是最优解？
1. 时间复杂度`O(m*n)`：每个元素仅访问一次，是矩阵遍历的理论最优复杂度；
2. 空间复杂度`O(1)`（除结果存储外）：仅用4个边界变量和1个方向标记，无额外空间开销；
3. 逻辑清晰、易实现、无冗余操作：相比「标记访问法」（需额外数组记录是否访问），无需额外空间，效率更高；相比「递归法」，无栈溢出风险，更适合大矩阵。

### 完整实现代码（C++版，通用所有二维矩阵）
代码适配**任意行列数的二维矩阵**（行≠列也能处理，比如2行3列、4行5列），注释清晰，直接可运行：
```cpp
#include <iostream>
#include <vector>
using namespace std;

// 顺时针螺旋遍历二维矩阵，返回遍历结果
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> res;
    if (matrix.empty() || matrix[0].empty()) return res; // 空矩阵直接返回

    // 定义四个边界：上、下、左、右
    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;

    while (true) {
        // 1. 从左到右遍历上边界 → 完成后上边界向下收缩
        for (int i = left; i <= right; ++i) res.push_back(matrix[top][i]);
        if (++top > bottom) break; // 边界交叉，退出循环

        // 2. 从上到下遍历右边界 → 完成后右边界向左收缩
        for (int i = top; i <= bottom; ++i) res.push_back(matrix[i][right]);
        if (--right < left) break;

        // 3. 从右到左遍历下边界 → 完成后下边界向上收缩
        for (int i = right; i >= left; --i) res.push_back(matrix[bottom][i]);
        if (--bottom < top) break;

        // 4. 从下到上遍历左边界 → 完成后左边界向右收缩
        for (int i = bottom; i >= top; --i) res.push_back(matrix[i][left]);
        if (++left > right) break;
    }
    return res;
}

// 测试示例
int main() {
    vector<vector<int>> matrix = {{1,2,3}, {4,5,6}, {7,8,9}};
    vector<int> result = spiralOrder(matrix);

    // 输出结果：1 2 3 6 9 8 7 4 5
    for (int num : result) cout << num << " ";
    cout << endl;

    return 0;
}
```

### 核心逻辑拆解（以你的3x3矩阵为例）
初始边界：`top=0`（第一行）、`bottom=2`（第三行）、`left=0`（第一列）、`right=2`（第三列），循环执行四步遍历，每步后收缩边界：
1. **左→右（上边界）**：遍历`matrix[0][0]~matrix[0][2]` → 1,2,3 → `top`变为1（上边界下移到第二行）；
2. **上→下（右边界）**：遍历`matrix[1][2]~matrix[2][2]` →6,9 → `right`变为1（右边界左移到第二列）；
3. **右→左（下边界）**：遍历`matrix[2][1]~matrix[2][0]` →8,7 → `bottom`变为1（下边界上移到第二行）；
4. **下→上（左边界）**：遍历`matrix[1][0]` →4 → `left`变为1（左边界右移到第二列）；
5. 再次进入循环，**左→右遍历上边界**：遍历`matrix[1][1]` →5 → `top`变为2，此时`top>bottom`（2>1），边界交叉，循环退出。

最终遍历结果：`1,2,3,6,9,8,7,4,5`，和题目要求完全一致。

### 关键细节（避坑点）
1. **边界收缩后立即判断交叉**：每一步遍历完成后，必须先收缩边界，再判断是否交叉（比如`++top > bottom`），避免重复遍历最后一个元素；
2. **空矩阵处理**：开头先判断矩阵是否为空（行空或列空），防止数组越界；
3. **循环条件用`while(true)`**：无需额外的循环条件，靠内部边界交叉判断退出，逻辑更简洁；
4. **遍历方向的索引范围**：左→右/上→下是`<=`，右→左/下→上是`>=`，不要写反。

### 扩展：适配非正方形矩阵
这个方法对**非正方形矩阵**同样有效，比如测试用例`{{1,2,3,4},{5,6,7,8},{9,10,11,12}}`（3行4列），遍历结果为`1,2,3,4,8,12,11,10,9,5,6,7`，完全符合顺时针螺旋规则。

### 总结
解决二维矩阵顺时针遍历问题，**边界收缩法**是工业界和算法题中的**最优解**，核心记住：
1. 四个边界标记上下左右，按「右→下→左→上」遍历；
2. 遍历完一个方向就收缩对应边界，立即判断是否交叉；
3. 时间`O(mn)`、空间`O(1)`（除结果），无冗余、无溢出，适配所有二维矩阵。

这个解法代码量少、逻辑清晰，无论是笔试刷题还是实际开发，都是首选方案。