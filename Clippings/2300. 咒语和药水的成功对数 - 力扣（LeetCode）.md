---
title: "2300. 咒语和药水的成功对数 - 力扣（LeetCode）"
source: "https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/?envType=daily-question&envId=2025-10-08"
author:
  - "[[力扣 LeetCode]]"
published:
created: 2025-10-08
description: "2300. 咒语和药水的成功对数 - 给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。 示例 1：输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7输出：[4,0,3]解释：- 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。所以返回 [4,0,3] 。示例 2：输入：spells = [3,1,2], potions = [8,5,8], success = 16输出：[2,0,2]解释：- 第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。- 第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。所以返回 [2,0,2] 。 提示： * n == spells.length * m == potions.length * 1 <= n, m <= 105 * 1 <= spells[i], potions[i] <= 105 * 1 <= success <= 1010"
tags:
  - "clippings"
---

[2300\. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

已解答

1477

相关标签

相关企业

提示

给你两个正整数数组 `spells` 和  `potions`  ，长度分别为  `n` 和  `m`  ，其中  `spells[i]` 表示第 `i`  个咒语的能量强度， `potions[j]` 表示第 `j` 瓶药水的能量强度。

同时给你一个整数 `success` 。一个咒语和药水的能量强度 **相乘** 如果 **大于等于** `success` ，那么它们视为一对 **成功** 的组合。

请你返回一个长度为 `n` 的整数数组 `pairs` ，其中 `pairs[i]` 是能跟第 `i` 个咒语成功组合的 **药水** 数目。

**示例 1：**

```
输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7
输出：[4,0,3]
解释：
- 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。
- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。
- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。
所以返回 [4,0,3] 。
```

**示例 2：**

```
输入：spells = [3,1,2], potions = [8,5,8], success = 16
输出：[2,0,2]
解释：
- 第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。
- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。
- 第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。
所以返回 [2,0,2] 。
```

**提示：**

- `n == spells.length`
- `m == potions.length`
- `1 <= n, m <= 10<sup>5</sup>`
- `1 <= spells[i], potions[i] <= 10<sup>5</sup>`
- `1 <= success <= 10<sup>10</sup>`

---

面试中遇到过这道题?

1/5

是

否

通过次数

76,956 /158.8K

通过率

48.5 %

---

---

相关企业

---

提示1

Notice that if a spell and potion pair is successful, then the spell and all stronger potions will be successful too.

---

提示2

Thus, for each spell, we need to find the potion with the least strength that will form a successful pair.

---

提示3

We can efficiently do this by sorting the potions based on strength and using binary search.

---

---


## 解法

```` tab
tab:bfs
``` cpp
class Solution {
private:
    vector<vector<int>> mode = {{0,1}, {1,0}, {0,-1}, {-1, 0}};
    vector<vector<int>> visited;
    queue<tuple<int, int, int>> q; // [r, c, direction]

public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        auto legal = [=](int r, int c) {
            return 0 <= r && r < m && 0 <= c && c < n;
        };

        int ans = m * n;
        visited.assign(m, vector<int>(n, 0));
        for (int i = 0; i < walls.size(); i++) {
            auto r = walls[i][0], c = walls[i][1];
            visited[r][c] = -1; // 对应wall
            ans--;
        }

        for (int i = 0; i < guards.size(); i++) {
            auto r = guards[i][0], c = guards[i][1];
            visited[r][c] = -2; // 对应guard
            ans--;
            for (int k = 0, nr, nc; k < 4; k++) {
                nr = r + mode[k][0];
                nc = c + mode[k][1];
                if (legal(nr, nc)) {
                    q.push({nr, nc, k});
                }
            }
        } // 加入所有Guard能看到的最近的四个方向的格子


        while (!q.empty()) { // 不断循环
            auto [r, c, d] = q.front(); q.pop();
            // 1为访问过了, 0为没有访问过, -1为wall, -2为guard,
            if (visited[r][c] < 0) {
                continue;
            } else {
                if (visited[r][c] == 0) {
                     ans--;
                     visited[r][c] = 1;
                }
                auto nr = r + mode[d][0], nc = c + mode[d][1];
                if (legal(nr, nc)) q.push({nr, nc, d}); 
            }
        }

        return ans;
    }
};
```

tab:直接传递
``` cpp
class Solution {
    // 左右上下
    static constexpr int DIRS[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector guarded(m, vector<int8_t>(n));

        // 标记警卫格子、墙格子
        for (auto& g : guards) {
            guarded[g[0]][g[1]] = -1;
        }
        for (auto& w : walls) {
            guarded[w[0]][w[1]] = -1;
        }

        // 遍历警卫
        for (auto& g : guards) {
            // 遍历视线方向（左右上下）
            for (auto& [dx, dy] : DIRS) {
                // 视线所及之处，被保卫
                int x = g[0] + dx, y = g[1] + dy;
                while (0 <= x && x < m && 0 <= y && y < n && guarded[x][y] != -1) {
                    guarded[x][y] = 1; // 被保卫
                    x += dx;
                    y += dy;
                }
            }
        }

        // 统计没被保卫（值为 0）的格子数
        int ans = 0;
        for (auto& row : guarded) {
            ans += ranges::count(row, 0);
        }
        return ans;
    }
};
```

```` 
