# AIoT智能消防疏散系统毕业设计方案
## 一、系统整体架构设计
本系统基于AIoT架构，核心分为**数据收集层**、**AI智能分析层**、**路径规划层**、**通信层**、**终端执行层**五部分，以主机（服务器）为核心，实现火灾状态识别、最优疏散路径规划、终端设备联动通知的全流程闭环。

### 系统拓扑图（文字描述）
```
主机服务器（核心）
├── 数据收集层：烟雾传感器、温度传感器、火焰传感器、摄像头（部署于教室/走廊/楼梯）
├── AI智能分析层：火灾识别模型、环境状态评估模型（部署于服务器）
├── 路径规划层：动态路径算法+AI优化（部署于服务器）
├── 通信层：WiFi/4G/LoRa（服务器与子设备通信）
└── 终端执行层：教室子设备（显示屏、语音播报器、指示灯）
```

## 二、数据收集系统设计（核心模块1）
### 1. 硬件选型（低成本+易实现，适配毕设）
| 设备类型       | 型号/规格                | 部署位置          | 采集参数                |
|----------------|--------------------------|-------------------|-------------------------|
| 烟雾传感器     | MQ-2                     | 教室、走廊、楼梯  | 烟雾浓度（0-1000ppm）|
| 温度传感器     | DS18B20                  | 同烟雾传感器      | 环境温度（-55~125℃）|
| 火焰传感器     | YG1006                   | 走廊、配电室      | 火焰有无（数字量）|
| 摄像头         | USB摄像头/树莓派摄像头   | 关键通道、楼梯口  | 实时视频流              |
| 教室子设备     | 单片机（STM32/ESP32）+ 显示屏+语音模块+指示灯 | 各教室 | 接收指令、显示路径、语音播报 |
| 主机服务器     | 普通PC（Ubuntu系统）| 值班室            | 数据存储、AI推理、路径计算 |

### 2. 数据采集流程
#### （1）传感器数据采集
- 底层传感器通过ESP32单片机采集数据，经LoRa/WiFi以MQTT协议上传至服务器（轻量级物联网协议，适配毕设开发）；
- 采集频率：正常状态下5s/次，异常状态（如温度>50℃）触发1s/次高频采集；
- 数据格式（JSON）：
```json
{
  "device_id": "sensor_001",
  "timestamp": "2025-12-23 10:00:00",
  "smoke": 850,  // ppm
  "temperature": 65,  // ℃
  "flame": 1,  // 1=检测到火焰，0=未检测
  "location": "3号楼2层走廊东"
}
```

#### （2）视频数据采集与AI火灾识别
- 摄像头采集的视频流通过OpenCV实时读取（帧速率15fps），送入轻量化火灾识别模型（MobileNetV2+自定义分类头）；
- AI模型功能：识别视频帧中的火焰/烟雾特征，输出火灾置信度（0-1），置信度>0.8判定为火灾；
- 模型训练：使用公开火灾数据集（如FIRE-DATASET），标注火焰、烟雾、正常场景三类，在服务器端用PyTorch训练，训练完成后导出ONNX格式供实时推理。

### 3. 数据预处理
- 异常值过滤：传感器数据超出合理范围（如温度>125℃）标记为无效数据，采用滑动平均法补全；
- 数据融合：将传感器数值与AI视频识别结果融合，输出火灾综合判定结果（如：烟雾浓度850ppm+温度65℃+火焰识别置信度0.9 → 判定为火灾）；
- 数据存储：采用MySQL存储传感器历史数据、火灾事件记录，采用Redis缓存实时数据（便于路径规划调用）。

## 三、路径设计系统（核心模块2，含AI优化）
### 1. 核心需求
- 实时获取火灾位置、各通道拥堵状态（可通过摄像头AI识别人数）、通道是否被封堵；
- 为每个教室计算最优疏散路径（最短时间、最安全）；
- 动态更新路径：若疏散过程中火灾蔓延/通道拥堵，实时调整路径。

### 2. 基础算法+AI优化方案
#### （1）地图建模：楼层拓扑图
将教学楼抽象为图结构G=(V,E)：
- V（节点）：教室、走廊、楼梯、出口（标注坐标、节点类型）；
- E（边）：节点间的通道（标注长度、通行能力、是否连通）；
- 为每个边设置权重：权重=基础通行时间+风险系数（火灾区域附近权重×5，拥堵通道权重×2）。

#### （2）基础路径算法：Dijkstra算法
先通过Dijkstra计算每个教室到最近安全出口的最短路径（以权重为代价）。

#### （3）AI优化：强化学习（RL）调整路径
- 问题建模：
  - 智能体：路径规划模块；
  - 状态S：火灾位置、各节点拥堵人数、通道状态、教室位置；
  - 动作A：选择下一个疏散节点；
  - 奖励函数R：
    ```
    R = 10/疏散时间 - 5×风险系数 - 2×拥堵系数
    （疏散时间越短、风险越低、拥堵越少，奖励越高）
    ```
- 训练方式：
  - 离线训练：基于教学楼不同火灾场景（如一楼走廊火灾、二楼教室火灾）、不同拥堵状态生成模拟数据，训练DQN（深度Q网络）模型；
  - 在线微调：实际运行中，根据疏散反馈（如是否成功到达出口）微调模型参数；
- 优势：相比传统算法，RL能应对动态场景（如火灾蔓延、突发拥堵），输出更优的疏散策略。

### 3. 路径规划流程
1. **火灾定位**：数据收集层确定火灾位置（如3号楼2层走廊东），标记该区域及周边节点为高风险；
2. **拥堵检测**：摄像头采集各通道人数，AI（YOLOv8）识别人数，计算拥堵系数（人数/通道通行能力）；
3. **图权重更新**：根据火灾风险、拥堵系数更新图G的边权重；
4. **路径计算**：
   - 第一步：Dijkstra计算初始最短路径；
   - 第二步：RL模型优化路径（如避开高风险/高拥堵通道，选择次优但更安全的路径）；
5. **路径输出**：输出每个教室的疏散路径（如：301教室→2层西走廊→2号楼梯→1层大厅→北门出口）。

### 4. 动态路径更新
- 触发条件：火灾蔓延（传感器检测到新区域温度/烟雾升高）、通道拥堵系数>0.8、通道封堵（摄像头识别到障碍物）；
- 更新频率：路径规划模块每5s重新计算一次路径，同步至对应教室子设备。

## 四、通信系统设计
### 1. 通信协议选型
| 通信场景                | 协议/方式       | 优势                  |
|-------------------------|-----------------|-----------------------|
| 传感器→服务器           | MQTT            | 轻量级、低功耗、易部署 |
| 服务器→教室子设备       | TCP/UDP + 自定义指令 | 实时性高、指令解析快  |
| 视频流传输              | RTSP            | 适配摄像头、实时性好  |

### 2. 指令格式（服务器→子设备）
```json
{
  "class_id": "301",  // 教室编号
  "fire_status": 1,   // 1=火灾，0=正常
  "path": "301→2层西走廊→2号楼梯→北门出口",  // 疏散路径
  "warning": "火灾！请沿2层西走廊向2号楼梯疏散！",  // 语音播报内容
  "update_time": "2025-12-23 10:01:00"
}
```

### 3. 通信流程
1. 服务器实时接收传感器/摄像头数据，经AI分析判定火灾；
2. 服务器触发路径规划模块，计算各教室最优路径；
3. 服务器通过TCP协议将路径指令、告警信息下发至对应教室的ESP32子设备；
4. 子设备接收指令后，触发语音播报、显示屏显示路径、指示灯闪烁（红色=告警，绿色=疏散方向）；
5. 子设备定期（1s/次）向服务器反馈状态（如：已接收指令、当前教室人数）。

## 五、软件实现（核心代码框架）
### 1. 服务器端（Python实现，Ubuntu系统）
#### （1）数据采集模块（MQTT接收传感器数据）
```python
import paho.mqtt.client as mqtt
import json
import mysql.connector

# MQTT配置
MQTT_BROKER = "localhost"
MQTT_PORT = 1883
MQTT_TOPIC = "fire/sensor/data"

# 数据库连接
db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="123456",
    database="fire_system"
)
cursor = db.cursor()

# MQTT回调函数
def on_message(client, userdata, msg):
    data = json.loads(msg.payload.decode())
    # 数据预处理（过滤异常值）
    if 0 < data["temperature"] < 125 and 0 < data["smoke"] < 1000:
        # 插入数据库
        sql = "INSERT INTO sensor_data (device_id, timestamp, smoke, temperature, flame, location) VALUES (%s, %s, %s, %s, %s, %s)"
        val = (data["device_id"], data["timestamp"], data["smoke"], data["temperature"], data["flame"], data["location"])
        cursor.execute(sql, val)
        db.commit()
        # 触发火灾判定
        fire_detection(data)

# 火灾综合判定
def fire_detection(data):
    # AI视频识别结果（从Redis读取）
    ai_flame_conf = redis_client.get(f"ai_flame_{data['location']}")
    ai_flame_conf = float(ai_flame_conf) if ai_flame_conf else 0
    # 判定条件
    if data["smoke"] > 800 and data["temperature"] > 60 and ai_flame_conf > 0.8:
        print(f"火灾报警！位置：{data['location']}")
        # 触发路径规划
        path_planning(data["location"])

# 启动MQTT客户端
client = mqtt.Client()
client.on_message = on_message
client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.subscribe(MQTT_TOPIC)
client.loop_forever()
```

#### （2）路径规划模块（Dijkstra+RL优化）
```python
import networkx as nx
import torch
import torch.nn as nn

# 1. 构建楼层拓扑图
G = nx.Graph()
# 添加节点（教室、走廊、楼梯、出口）
G.add_nodes_from([
    ("301", {"type": "class", "pos": (20, 30)}),
    ("2层西走廊", {"type": "corridor", "pos": (15, 30)}),
    ("2号楼梯", {"type": "stair", "pos": (15, 0)}),
    ("北门出口", {"type": "exit", "pos": (0, 0)})
])
# 添加边（基础权重=通行时间）
G.add_edge("301", "2层西走廊", weight=5)
G.add_edge("2层西走廊", "2号楼梯", weight=10)
G.add_edge("2号楼梯", "北门出口", weight=8)

# 2. Dijkstra最短路径
def dijkstra_path(G, start, end):
    return nx.dijkstra_path(G, source=start, target=end, weight="weight")

# 3. RL优化模型（DQN简化版）
class DQN(nn.Module):
    def __init__(self, state_dim, action_dim):
        super(DQN, self).__init__()
        self.fc1 = nn.Linear(state_dim, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, action_dim)
    
    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        return self.fc3(x)

# 路径规划主函数
def path_planning(fire_location):
    # 更新图权重（火灾区域附近权重×5）
    for u, v in G.edges():
        if fire_location in [u, v] or "2层东走廊" in [u, v]:  # 火灾周边
            G[u][v]["weight"] *= 5
        # 拥堵通道权重×2（从Redis读取拥堵系数）
        congestion = float(redis_client.get(f"congestion_{u}_{v}") or 1)
        G[u][v]["weight"] *= congestion
    
    # 基础路径
    base_path = dijkstra_path(G, "301", "北门出口")
    # RL优化（简化版：加载预训练模型，调整路径）
    state = get_state(fire_location, G)  # 获取当前状态（火灾位置、拥堵等）
    state_tensor = torch.tensor(state, dtype=torch.float32)
    dqn_model = torch.load("dqn_fire_path.pth")  # 加载预训练模型
    action = dqn_model(state_tensor).argmax().item()
    optimized_path = adjust_path(base_path, action)  # 根据动作调整路径
    
    # 下发路径至教室子设备
    send_to_device("301", optimized_path)

def send_to_device(class_id, path):
    # TCP发送指令
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("子设备IP", 8080))  # 教室子设备IP+端口
    cmd = json.dumps({
        "class_id": class_id,
        "fire_status": 1,
        "path": "→".join(path),
        "warning": f"火灾！请沿{path}疏散！"
    })
    s.send(cmd.encode())
    s.close()
```

### 2. 教室子设备（ESP32实现）
```c
#include <WiFi.h>
#include <WiFiClient.h>
#include <ArduinoJson.h>

// WiFi配置
const char* ssid = "your_wifi";
const char* password = "your_password";
const char* server_ip = "服务器IP";
const int server_port = 8080;

// 硬件引脚
#define LCD_PIN 13  // 显示屏引脚
#define VOICE_PIN 14  // 语音模块引脚
#define LED_PIN 15  // 指示灯引脚

WiFiClient client;

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  // 连接WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  // 连接服务器
  if (!client.connect(server_ip, server_port)) {
    Serial.println("连接服务器失败");
    return;
  }
}

void loop() {
  if (client.available()) {
    String data = client.readStringUntil('\n');
    DynamicJsonDocument doc(256);
    deserializeJson(doc, data);
    // 解析指令
    int fire_status = doc["fire_status"];
    String path = doc["path"];
    String warning = doc["warning"];
    
    if (fire_status == 1) {
      // 触发告警
      digitalWrite(LED_PIN, HIGH);  // 红灯闪烁
      // 显示屏显示路径
      lcd_display(path);
      // 语音播报
      voice_play(warning);
    } else {
      digitalWrite(LED_PIN, LOW);
      lcd_display("正常状态");
    }
  }
  delay(1000);
}

// 显示屏显示
void lcd_display(String content) {
  // 适配LCD1602等显示屏驱动
  Serial.println("显示：" + content);
}

// 语音播报
void voice_play(String content) {
  // 适配SYN6288等语音模块
  Serial.println("播报：" + content);
}
```

## 六、系统测试与毕设展示
### 1. 测试场景
- 模拟火灾：手动设置3号楼2层东走廊传感器数据（烟雾850ppm、温度65℃），摄像头播放火灾视频；
- 验证路径：301教室的最优路径应避开2层东走廊，选择2层西走廊→2号楼梯→北门出口；
- 动态更新：模拟2号楼梯拥堵，验证路径是否更新为301→2层西走廊→3号楼梯→南门出口。

### 2. 毕设展示要点
- 系统演示：运行服务器程序，展示传感器数据采集、AI火灾识别、路径规划、子设备告警的全流程；
- 技术亮点：
  - 数据收集：多传感器+AI视频融合的火灾判定；
  - 路径规划：Dijkstra+强化学习的动态优化；
  - 通信：MQTT/TCP的跨设备联动；
- 成果文档：系统设计文档、代码注释、测试报告、演示视频。

## 七、毕设优化建议（可选）
1. 低成本替代：若硬件不足，可先用Python模拟传感器数据、虚拟教室子设备，重点展示AI算法和路径规划；
2. 界面可视化：用Python的PyQt5/Streamlit制作服务器可视化界面，展示实时数据、火灾位置、疏散路径；
3. 轻量化AI：若服务器性能不足，将火灾识别模型换成更轻量的MobileNetV1，或使用EdgeAI（如树莓派）进行本地推理。

该方案兼顾毕设的可行性（低成本、易实现）和技术深度（AI优化、物联网通信），符合本科毕业设计的要求，可根据实际硬件条件灵活调整。